package gdsc.smlm.ij.plugins;

/*----------------------------------------------------------------------------- 
 * GDSC SMLM Software
 * 
 * Copyright (C) 2016 Alex Herbert
 * Genome Damage and Stability Centre
 * University of Sussex, UK
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *---------------------------------------------------------------------------*/

import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import org.apache.commons.math3.analysis.interpolation.LinearInterpolator;
import org.apache.commons.math3.analysis.interpolation.LoessInterpolator;
import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.Well44497b;

import gdsc.core.ij.BufferedTextWindow;
import gdsc.core.ij.Utils;
import gdsc.core.logging.TrackProgress;
import gdsc.core.match.ClassificationResult;
import gdsc.core.match.FractionClassificationResult;
import gdsc.core.match.FractionalAssignment;
import gdsc.core.match.ImmutableFractionalAssignment;
import gdsc.core.utils.Maths;
import gdsc.core.utils.RampedScore;
import gdsc.core.utils.StoredDataStatistics;
import gdsc.core.utils.UnicodeReader;
import gdsc.smlm.engine.FitEngineConfiguration;
import gdsc.smlm.engine.ResultGridManager;
import gdsc.smlm.fitting.FitConfiguration;
import gdsc.smlm.ga.Chromosome;
import gdsc.smlm.ga.ChromosomeComparator;
import gdsc.smlm.ga.FitnessFunction;
import gdsc.smlm.ga.Population;
import gdsc.smlm.ga.RampedSelectionStrategy;
import gdsc.smlm.ga.Recombiner;
import gdsc.smlm.ga.SelectionStrategy;
import gdsc.smlm.ga.SimpleMutator;
import gdsc.smlm.ga.SimpleRecombiner;
import gdsc.smlm.ga.SimpleSelectionStrategy;
import gdsc.smlm.ga.ToleranceChecker;
import gdsc.smlm.ij.plugins.BenchmarkSpotFit.FilterCandidates;
import gdsc.smlm.ij.settings.FilterSettings;
import gdsc.smlm.ij.settings.GlobalSettings;
import gdsc.smlm.ij.settings.SettingsManager;
import gdsc.smlm.results.MemoryPeakResults;
import gdsc.smlm.results.PeakResult;
import gdsc.smlm.results.filter.BasePreprocessedPeakResult;
import gdsc.smlm.results.filter.DirectFilter;
import gdsc.smlm.results.filter.Filter;
import gdsc.smlm.results.filter.FilterSet;
import gdsc.smlm.results.filter.FilterType;
import gdsc.smlm.results.filter.IMultiFilter;
import gdsc.smlm.results.filter.MultiPathFilter;
import gdsc.smlm.results.filter.MultiPathFitResult;
import gdsc.smlm.results.filter.MultiPathFitResults;
import gdsc.smlm.results.filter.ResultAssignment;
import gdsc.smlm.results.filter.XStreamWrapper;
import gdsc.smlm.utils.XmlUtils;
import ij.IJ;
import ij.Prefs;
import ij.gui.GenericDialog;
import ij.gui.Plot2;
import ij.gui.PlotWindow;
import ij.plugin.PlugIn;
import ij.plugin.WindowOrganiser;
import ij.text.TextWindow;

/**
 * Run different filtering methods on a set of benchmark fitting results outputting performance statistics on the
 * success of the filter. The fitting results are generated by the BenchmarkSpotFit plugin.
 * <p>
 * Filtering is done using e.g. SNR threshold, Precision thresholds, etc. The statistics reported are shown in a table,
 * e.g. precision, Jaccard, F-score.
 */
public class BenchmarkFilterAnalysis implements PlugIn, FitnessFunction, TrackProgress
{
	private static final String TITLE = "Benchmark Filter Analysis";
	private static TextWindow resultsWindow = null;
	private static TextWindow summaryWindow = null;
	private static TextWindow sensitivityWindow = null;
	private static TextWindow gaWindow = null;
	private static int failCount = 1;
	private static int failCountRange = 0;
	private static double residualsThreshold = 0.3;
	private static boolean reset = true;
	private static boolean showResultsTable = false;
	private static boolean showSummaryTable = true;
	private static boolean clearTables = false;
	private static String filterFilename = "";
	private static String filterSetFilename = "";
	private static String templateFilename = "";
	private static int summaryTopN = 0;
	private static double summaryDepth = 500;
	private static int plotTopN = 0;
	private static boolean saveBestFilter = false;
	private static boolean saveTemplate = false;
	private ArrayList<NamedPlot> plots;
	private static boolean calculateSensitivity = false;
	private static double delta = 0.1;
	private static int criteriaIndex;
	private static double criteriaLimit = 0.95;
	private double minCriteria = 0;
	private boolean invertCriteria = false;
	private static int scoreIndex;
	private boolean invertScore = false;
	private static double upperMatchDistance = 100;
	private static double partialMatchDistance = 33;
	static double distanceInPixels;
	static double lowerDistanceInPixels;
	private static double upperSignalFactor = 100;
	private static double partialSignalFactor = 50;
	static double signalFactor;
	static double lowerSignalFactor;
	private static boolean depthRecallAnalysis = true;
	private static boolean scoreAnalysis = true;
	private static boolean evolve = false;
	private static int stepSearch = 0;

	private static int populationSize = 500;
	private static int failureLimit = 5;
	private static double tolerance = 1e-4;
	private static int convergedCount = 2;
	private static double crossoverRate = 1;
	private static double meanChildren = 2;
	private static double mutationRate = 1;
	private static double selectionFraction = 0.2;
	private static boolean rampedSelection = true;
	private static boolean strictFitness = true;
	private static boolean saveOption = false;

	private static String resultsTitle;
	private String resultsPrefix, resultsPrefix2, limitFailCount;
	private static String resultsPrefix3, limitRange;

	private HashMap<String, FilterScore> bestFilter;
	private LinkedList<String> bestFilterOrder;

	private static boolean reUseFilters = true;
	private static boolean expandFilters = true;
	private static String oldFilename = "";
	private static long lastModified = 0;
	private static List<FilterSet> filterList = null;
	private static boolean[][] wasNotExpanded;
	private static double[][] lowerLimit;
	private static double[][] upperLimit;
	private static double[][] increment;
	private static int lastId = 0;
	private static HashMap<Integer, IdPeakResult[]> actualCoordinates = null;
	private static double lastUpperMatchDistance = -1, lastPartialMatchDistance = -1;
	private static double lastUpperSignalFactor = -1, lastPartialSignalFactor = -1;
	private static MultiPathFitResults[] resultsList = null;
	private static MultiPathFitResults[] clonedResultsList = null;
	private static int candidates; // This may be in the results prefix already... 
	private static int matches;
	private static int totalResults;
	private static StoredDataStatistics depthStats, depthFitStats, signalFactorStats, distanceStats;

	private boolean isHeadless;
	private long totalTime = 0, currentTime;

	// Used to tile plot windows
	private WindowOrganiser wo = new WindowOrganiser();

	public class CustomFractionalAssignment extends ImmutableFractionalAssignment
	{
		public final double sf;
		public final PeakResult peak;

		public CustomFractionalAssignment(int targetId, int predictedId, double distance, double score, double sf,
				PeakResult peak)
		{
			super(targetId, predictedId, distance, score);
			this.sf = sf;
			this.peak = peak;
		}
	}

	public class CustomResultAssignment extends ResultAssignment
	{
		public final double sf;
		public final PeakResult peak;

		public CustomResultAssignment(int targetId, double distance, double score, double sf, PeakResult peak)
		{
			super(targetId, distance, score);
			this.sf = sf;
			this.peak = peak;
		}

		@Override
		public FractionalAssignment toFractionalAssignment(int predictedId)
		{
			return new CustomFractionalAssignment(targetId, predictedId, distance, score, sf, peak);
		}
	}

	private class IdPeakResult extends PeakResult
	{
		final int id;

		public IdPeakResult(int id, PeakResult result)
		{
			super(result.peak, result.origX, result.origY, result.origValue, result.error, result.noise, result.params,
					null);
			this.id = id;
		}
	}

	private class Job
	{
		final Entry<Integer, FilterCandidates> entry;

		Job(Entry<Integer, FilterCandidates> entry)
		{
			this.entry = entry;
		}
	}

	/**
	 * Used to allow multi-threading of the scoring the fit results
	 */
	private class FitResultsWorker implements Runnable
	{
		volatile boolean finished = false;
		final BlockingQueue<Job> jobs;
		final List<MultiPathFitResults> results;
		final double matchDistance;
		final RampedScore distanceScore;
		final RampedScore signalScore;
		int matches = 0;
		int total = 0;

		public FitResultsWorker(BlockingQueue<Job> jobs, List<MultiPathFitResults> syncResults, double matchDistance,
				RampedScore distanceScore, RampedScore signalScore)
		{
			this.jobs = jobs;
			this.results = syncResults;
			this.matchDistance = matchDistance;
			this.distanceScore = distanceScore;
			this.signalScore = signalScore;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Runnable#run()
		 */
		public void run()
		{
			try
			{
				while (!finished)
				{
					Job job = jobs.take();
					if (job == null || job.entry == null || finished)
						break;
					run(job);
				}
			}
			catch (InterruptedException e)
			{
				System.out.println(e.toString());
				throw new RuntimeException(e);
			}
			finally
			{
				finished = true;
			}
		}

		private void run(Job job)
		{
			if (Utils.isInterrupted())
			{
				finished = true;
				return;
			}

			showProgress();

			final int frame = job.entry.getKey();
			final FilterCandidates result = job.entry.getValue();

			synchronized (depthStats)
			{
				depthStats.add(result.zPosition);
				candidates += result.spots.length;
			}

			final PeakResult[] actual = getCoordinates(actualCoordinates, frame);
			final boolean[] matched = new boolean[actual.length];
			// We could use distanceInPixels for the resolution. Using a bigger size may allow the 
			// different fit locations to be inthe same cell and so the grid manager can use it's cache.
			final double resolution = 2 * distanceInPixels;
			final ResultGridManager resultGrid = new ResultGridManager(actual, resolution);

			final MultiPathFitResult[] multiPathFitResults = new MultiPathFitResult[result.fitResult.length];
			int size = 0;

			// TODO - support a multi-pass filter.
			// The results are in order they were fit.
			// For a single pass fitter this will be in order of candidate ranking.
			// For a multi pass fitter this will be in order of candidate ranking, then repeat.
			int failCount = 0;
			for (int index = 0; index < multiPathFitResults.length; index++)
			{
				final MultiPathFitResult fitResult = result.fitResult[index];

				// Score the results. Do in order of those likely to be in the same position
				// thus the grid manager can cache the neighbours
				boolean fitted = score(fitResult.getSingleFitResult(), resultGrid, matchDistance, distanceScore,
						signalScore, matched);
				fitted |= score(fitResult.getDoubletFitResult(), resultGrid, matchDistance, distanceScore, signalScore,
						matched);
				fitted |= score(fitResult.getMultiFitResult(), resultGrid, matchDistance, distanceScore, signalScore,
						matched);

				if (fitted)
				{
					fitResult.originalFailCount = failCount;
					multiPathFitResults[size++] = fitResult;
					failCount = 0;
				}
				else
				{
					// This was not fitted by any method so will always be a fail
					failCount++;
				}
			}

			// Count number of results that had a match
			for (int i = 0; i < matched.length; i++)
				if (matched[i])
					matches++;
			total += size;

			results.add(new MultiPathFitResults(frame, Arrays.copyOf(multiPathFitResults, size), result.spots.length));
		}
	}

	// Store the best filter scores
	private class FilterResult
	{
		final DirectFilter filter;
		final double score;
		final int failCount;
		final int failCountRange;

		public FilterResult(DirectFilter filter, double score, int failCount, int failCountRange)
		{
			this.filter = filter;
			this.score = score;
			this.failCount = failCount;
			this.failCountRange = failCountRange;
		}
	}

	private static ArrayList<FilterResult> scores = new ArrayList<FilterResult>();

	private static String[] COLUMNS = {
			// Scores using integer scoring		
			"TP", "FP", "FN", "Precision", "Recall", "F1", "Jaccard",
			// Scores using fractional scoring 
			"fTP", "fFP", "fFN", "fPrecision", "fRecall", "fF1", "fJaccard", };

	private static boolean[] showColumns;
	private boolean requireIntegerResults;
	static
	{
		showColumns = new boolean[COLUMNS.length];
		Arrays.fill(showColumns, true);
		//showColumns[0] = false; // nP

		// Use the precision as criteria to ensure a set confidence on results labelled as true
		criteriaIndex = COLUMNS.length - 4;
		// Score using Jaccard
		scoreIndex = COLUMNS.length - 1;

		String currentUsersHomeDir = System.getProperty("user.home");
		templateFilename = currentUsersHomeDir + File.separator + "gdsc.smlm" + File.separator + "template";
	}

	private CreateData.SimulationParameters simulationParameters;
	private MemoryPeakResults results;

	public BenchmarkFilterAnalysis()
	{
		isHeadless = java.awt.GraphicsEnvironment.isHeadless();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see ij.plugin.PlugIn#run(java.lang.String)
	 */
	public void run(String arg)
	{
		SMLMUsageTracker.recordPlugin(this.getClass(), arg);

		simulationParameters = CreateData.simulationParameters;
		if (simulationParameters == null)
		{
			IJ.error(TITLE, "No benchmark spot parameters in memory");
			return;
		}
		results = MemoryPeakResults.getResults(CreateData.CREATE_DATA_IMAGE_TITLE + " (Create Data)");
		if (results == null)
		{
			IJ.error(TITLE, "No benchmark results in memory");
			return;
		}
		if (BenchmarkSpotFit.fitResults == null)
		{
			IJ.error(TITLE, "No benchmark fitting results in memory");
			return;
		}
		if (BenchmarkSpotFit.lastId != simulationParameters.id)
		{
			IJ.error(TITLE, "Update the benchmark spot fitting for the latest simulation");
			return;
		}
		if (BenchmarkSpotFit.lastFilterId != BenchmarkSpotFilter.filterResult.id)
		{
			IJ.error(TITLE, "Update the benchmark spot fitting for the latest filter");
			return;
		}

		resultsList = readResults();
		if (resultsList == null)
		{
			IJ.error(TITLE, "No results could be loaded");
			return;
		}

		if (!showDialog())
			return;

		// Load filters from file
		List<FilterSet> filterSets = readFilterSets();

		if (filterSets == null || filterSets.isEmpty())
		{
			IJ.error(TITLE, "No filters specified");
			return;
		}

		analyse(filterSets);

		final String timeString = Utils.timeToString(totalTime);
		// TODO - Decide where to write this.
		IJ.log("Filter analysis time : " + timeString);
		IJ.showStatus("Finished : " + timeString);
	}

	@SuppressWarnings("unchecked")
	private List<FilterSet> readFilterSets()
	{
		GlobalSettings gs = SettingsManager.loadSettings();
		FilterSettings filterSettings = gs.getFilterSettings();

		String filename = Utils.getFilename("Filter_File", filterSettings.filterSetFilename);
		if (filename != null)
		{
			IJ.showStatus("Reading filters ...");
			filterSettings.filterSetFilename = filename;

			// Allow the filters to be cached
			if (isSameFile(filename))
			{
				GenericDialog gd = new GenericDialog(TITLE);
				gd.hideCancelButton();
				gd.addMessage("The same filter file was selected.");
				gd.addCheckbox("Re-use_filters", reUseFilters);
				gd.showDialog();
				if (!gd.wasCanceled())
				{
					if ((reUseFilters = gd.getNextBoolean()))
					{
						SettingsManager.saveSettings(gs);
						return filterList;
					}
				}
			}

			BufferedReader input = null;
			setLastFile(null);
			try
			{
				FileInputStream fis = new FileInputStream(filename);
				input = new BufferedReader(new UnicodeReader(fis, null));
				Object o = XStreamWrapper.getInstance().fromXML(input);
				if (o != null && o instanceof List<?>)
				{
					SettingsManager.saveSettings(gs);
					List<FilterSet> filterSets = (List<FilterSet>) o;

					if (containsStandardFilters(filterSets))
					{
						IJ.log("Filter sets must contain 'Direct' filters");
						return null;
					}

					// Check they are not empty lists
					List<FilterSet> filterSets2 = new LinkedList<FilterSet>();
					for (FilterSet filterSet : filterSets)
					{
						if (filterSet.size() != 0)
						{
							filterSets2.add(filterSet);
						}
						else
						{
							IJ.log("Filter set empty: " + filterSet.getName());
						}
					}

					if (filterSets2.isEmpty())
					{
						IJ.log("All Filter sets are empty");
						return null;
					}

					// Maintain the same list type
					filterSets.clear();
					filterSets.addAll(filterSets2);

					filterList = filterSets;

					// Option to enumerate filters
					expandFilters();

					// Sort so that the filters are in a nice order
					for (FilterSet filterSet : filterList)
					{
						filterSet.sort();
					}

					setLastFile(filename);
					return filterList;
				}
				IJ.log("No filter sets defined in the specified file: " + filename);
			}
			catch (Exception e)
			{
				IJ.log("Unable to load the filter sets from file: " + e.getMessage());
			}
			finally
			{
				if (input != null)
				{
					try
					{
						input.close();
					}
					catch (IOException e)
					{
						// Ignore
					}
				}
				IJ.showStatus("");
			}
		}
		return null;
	}

	private boolean containsStandardFilters(List<FilterSet> filterSets)
	{
		for (FilterSet filterSet : filterSets)
		{
			for (Filter f : filterSet.getFilters())
			{
				if (f.getFilterType() == FilterType.STANDARD)
					return true;
			}
		}
		return false;
	}

	private static boolean wasNotExpanded(int setNumber, int parameterNumber)
	{
		setNumber--;
		if (wasNotExpanded[setNumber] == null)
			return true;
		return wasNotExpanded[setNumber][parameterNumber];
	}

	private static boolean wasExpanded(int setNumber)
	{
		setNumber--;
		if (wasNotExpanded[setNumber] == null)
			return false;
		for (int i = 0; i < wasNotExpanded[setNumber].length; i++)
			if (!wasNotExpanded[setNumber][i])
				return true;
		return false;
	}

	/**
	 * If filters have been provided in FiltersSets of 3 then expand the filters into a set assuming the three represent
	 * min:max:increment.
	 */
	private void expandFilters()
	{
		wasNotExpanded = new boolean[filterList.size()][];
		lowerLimit = new double[filterList.size()][];
		upperLimit = new double[filterList.size()][];
		increment = new double[filterList.size()][];
		long[] expanded = new long[filterList.size()];
		String[] name = new String[expanded.length];
		int c = 0;
		boolean doIt = false;
		for (FilterSet filterSet : filterList)
		{
			if (filterSet.size() == 3 && filterSet.allSameType())
			{
				name[c] = filterSet.getName();
				// Check we have min:max:increment
				Filter f1 = filterSet.getFilters().get(0);
				Filter f2 = filterSet.getFilters().get(1);
				Filter f3 = filterSet.getFilters().get(2);
				int n = f1.getNumberOfParameters();
				wasNotExpanded[c] = new boolean[n];
				lowerLimit[c] = new double[n];
				upperLimit[c] = new double[n];
				increment[c] = new double[n];
				long combinations = 1;
				for (int i = 0; i < n; i++)
				{
					wasNotExpanded[c][i] = true;
					if (f1.getParameterValue(i) < f2.getParameterValue(i) && f3.getParameterValue(i) > 0 &&
							!Double.isInfinite(f3.getParameterValue(i)))
					{
						wasNotExpanded[c][i] = false;
						// This can be expanded ... Count the combinations
						final double min = f1.getParameterValue(i);
						final double max = f2.getParameterValue(i);
						final double inc = f3.getParameterValue(i);
						final double max2 = max + inc;
						lowerLimit[c][i] = min;
						increment[c][i] = inc;
						long extra = 1;
						// Check the current value is less than the max or (to avoid small round-off error)
						// that the current value is closer to the max than the next value after the max.
						for (double d = min + inc; d < max || d - max < max2 - d; d += inc)
						{
							upperLimit[c][i] = d;
							extra++;
						}
						combinations *= extra;
					}
				}
				if (combinations > 1)
				{
					expanded[c] = combinations;
					doIt = true;
				}
			}
			c++;
		}

		if (!doIt)
			return;

		GenericDialog gd = new GenericDialog(TITLE);
		gd.hideCancelButton();
		StringBuilder sb = new StringBuilder("The filter file contains potential triples of min:max:increment.\n \n");
		for (c = 0; c < expanded.length; c++)
		{
			if (expanded[c] > 0)
			{
				sb.append("Expand set [").append((c + 1)).append("]");
				if (!Utils.isNullOrEmpty(name[c]))
					sb.append(" ").append(name[c]);
				sb.append(" to ").append(expanded[c]).append(" filters\n");
			}
		}
		gd.addMessage(sb.toString());
		gd.addCheckbox("Expand_filters", expandFilters);
		gd.showDialog();
		if (!gd.wasCanceled())
		{
			if (!(expandFilters = gd.getNextBoolean()))
				return;
		}

		IJ.showStatus("Expanding filters ...");

		List<FilterSet> filterList2 = new ArrayList<FilterSet>(filterList.size());
		final double DISABLED = 0;
		for (FilterSet filterSet : filterList)
		{
			c = filterList2.size();
			if (expanded[c] == 0)
			{
				filterList2.add(filterSet);
				continue;
			}

			List<Filter> list = new ArrayList<Filter>((int) expanded[c]);

			Filter f1 = filterSet.getFilters().get(0);
			Filter f2 = filterSet.getFilters().get(1);
			Filter f3 = filterSet.getFilters().get(2);
			final int n = f1.getNumberOfParameters();

			// Get the parameters for the two filters in the range

			// Check if parameters are disabled
			double[] parameters = new double[n];
			double[] parameters2 = new double[n];
			for (int i = 0; i < n; i++)
			{
				parameters[i] = f1.getParameterValue(i);
				parameters2[i] = f2.getParameterValue(i);
				if (wasNotExpanded[c][i])
				{
					if (Double.isInfinite(f3.getParameterValue(i)) || f3.getParameterValue(i) < 0)
					{
						// This is disabled
						parameters[i] = DISABLED;
						lowerLimit[c][i] = DISABLED;
						upperLimit[c][i] = DISABLED;
					}
				}
			}
			// Get the weakest parameters for those not expanded
			f1.weakestParameters(parameters2);
			for (int i = 0; i < n; i++)
			{
				if (wasNotExpanded[c][i] && parameters[i] != DISABLED)
				{
					parameters[i] = parameters2[i];
				}
			}
			f1 = f1.create(parameters);

			// Initialise with a filter set at the minimum for each parameter
			list.add(f1);
			for (int i = 0; i < n; i++)
			{
				if (!(f1.getParameterValue(i) < f2.getParameterValue(i) && f3.getParameterValue(i) > 0))
				{
					// No expansion of this parameter
					continue;
				}

				final double min = f1.getParameterValue(i);
				final double max = f2.getParameterValue(i);
				final double inc = f3.getParameterValue(i);
				final double max2 = max + inc;

				List<Filter> list2 = new LinkedList<Filter>();
				for (Filter f : list)
				{
					parameters = new double[n];
					for (int j = 0; j < n; j++)
						parameters[j] = f.getParameterValue(j);

					// We always have the min value set from the first filter so start at the next increment
					for (double d = min + inc; d < max || d - max < max2 - d; d += inc)
					{
						parameters[i] = d;
						list2.add(f.create(parameters));
					}
				}
				list.addAll(list2);
			}

			// Sort the filters
			Collections.sort(list);

			filterList2.add(new FilterSet(filterSet.getName(), list));
		}

		IJ.showStatus("");

		filterList = filterList2;
		Utils.log("Expanded input to %d filters in %s", countFilters(filterList),
				Utils.pleural(filterList.size(), "set"));
	}

	public boolean isSameFile(String filename)
	{
		if (filterList == null)
			return false;
		if (filename.equals(oldFilename))
		{
			try
			{
				File f = new File(filename);
				if (lastModified == f.lastModified())
				{
					return true;
				}
			}
			catch (Exception e)
			{
			}
		}
		return false;
	}

	private void setLastFile(String filename)
	{
		oldFilename = filename;
		if (oldFilename != null)
		{
			try
			{
				File f = new File(filename);
				lastModified = f.lastModified();
			}
			catch (Exception e)
			{
				lastModified = 0;
			}
		}
	}

	private MultiPathFitResults[] readResults()
	{
		boolean update = false;
		if (lastId != BenchmarkSpotFit.fitResultsId)
		{
			lastId = BenchmarkSpotFit.fitResultsId;
			update = true;
			actualCoordinates = getCoordinates(results.getResults());
			//actualSize = results.size(); // Should be simulationParameters.molecules
		}

		if (resultsList == null || update || lastPartialMatchDistance != partialMatchDistance ||
				lastUpperMatchDistance != upperMatchDistance || lastPartialSignalFactor != partialSignalFactor ||
				lastUpperSignalFactor != upperSignalFactor)
		{
			IJ.showStatus("Reading results ...");

			// Only cache results for the same analysis settings.
			// This functionality is for choosing the optimum fail limit.
			scores.clear();

			lastUpperMatchDistance = upperMatchDistance;
			lastPartialMatchDistance = partialMatchDistance;
			lastUpperSignalFactor = upperSignalFactor;
			lastPartialSignalFactor = partialSignalFactor;
			depthStats = new StoredDataStatistics();
			depthFitStats = new StoredDataStatistics();
			signalFactorStats = new StoredDataStatistics();
			distanceStats = new StoredDataStatistics();
			candidates = 0;
			matches = 0;
			totalResults = 0;

			// -=-=-=-
			// The scoring is designed to find the best fitter+filter combination for the given spot candidates.
			// The ideal combination would correctly fit+pick all the candidate positions that are close to a
			// localisation.
			//
			// Use the following scoring scheme for all candidates:
			// 
			//  Candidates
			// +----------------------------------------+  
			// |   Actual matches                       | 
			// |  +-----------+                TN       |
			// |  |  FN       |                         |
			// |  |      +----------                    |
			// |  |      | TP |    | Fitted             |
			// |  +-----------+    | spots              |
			// |         |     FP  |                    |
			// |         +---------+                    |
			// +----------------------------------------+
			//
			// Candidates     = All the spot candidates
			// Actual matches = Any spot candidate or fitted spot candidate that matches a localisation
			// Fitted spots   = Any spot candidate that was successfully fitted
			//
			// TP = A spot candidate that was fitted and matches a localisation and is accepted
			// FP = A spot candidate that was fitted but does not match a localisation and is accepted
			// FN = A spot candidate that failed to be fitted but matches a localisation
			//    = A spot candidate that was fitted and matches a localisation and is rejected
			// TN = A spot candidate that failed to be fitted and does not match a localisation
			//    = A spot candidate that was fitted and does not match a localisation and is rejected
			//
			// When fitting only produces one result it is possible to compute the TN score.
			// Since unfitted candidates can only be TN or FN we could accumulate these scores and cache them.
			// This was the old method of benchmarking single spot fitting and allowed more scores to be 
			// computed.
			//
			// When fitting produces multiple results then we have to score each fit result against all possible
			// actual results and keep a record of the scores. These can then be assessed when the specific 
			// results have been chosen by result filtering.
			//
			// Using a distance ramped scoring function the degree of match can be varied from 0 to 1.
			// Using a signal-factor ramped scoring function the degree of fitted can be varied from 0 to 1.
			// When using ramped scoring functions the fractional allocation of scores using the above scheme 
			// is performed, i.e. candidates are treated as if they both match and unmatch. This results in 
			// an equivalent to multiple analysis using different thresholds and averaging of the scores.
			//
			// The totals TP+FP+TN+FN must equal the number of spot candidates. This allows different fitting 
			// methods to be compared since the total number of candidates is the same.
			//
			// Precision = TP / (TP+FP)    : This is always valid as a minimum criteria score
			// Recall    = TP / (TP+FN)    : This is valid between different fitting methods since a method that 
			//                               fits more spots will have a potentially lower FN
			// Jaccard   = TP / (TP+FN+FP) : This is valid between fitting methods
			//
			// -=-=-=-
			// As an alternative scoring system, different fitting methods can be compared using the same TP 
			// value but calculating FN = localisations - TP and FP as Positives - TP. This creates a score 
			// against the original number of simulated molecules using everything that was passed through the 
			// filter (Positives). This score is comparable when a different spot candidate filter has been used 
			// and the total number of candidates is different, e.g. Mean filtering vs. Gaussian filtering
			// -=-=-=-

			final RampedScore distanceScore = new RampedScore(
					BenchmarkSpotFit.distanceInPixels * partialMatchDistance / 100.0,
					BenchmarkSpotFit.distanceInPixels * upperMatchDistance / 100.0);
			lowerDistanceInPixels = distanceScore.lower;
			distanceInPixels = distanceScore.upper;
			final double matchDistance = distanceInPixels * distanceInPixels;

			resultsPrefix3 = "\t" + Utils.rounded(distanceScore.lower * simulationParameters.a) + "\t" +
					Utils.rounded(distanceScore.upper * simulationParameters.a);
			limitRange = ", d=" + Utils.rounded(distanceScore.lower * simulationParameters.a) + "-" +
					Utils.rounded(distanceScore.upper * simulationParameters.a);

			// Signal factor must be greater than 1
			final RampedScore signalScore;
			if (BenchmarkSpotFit.signalFactor > 0)
			{
				signalScore = new RampedScore(BenchmarkSpotFit.signalFactor * partialSignalFactor / 100.0,
						BenchmarkSpotFit.signalFactor * upperSignalFactor / 100.0);
				lowerSignalFactor = signalScore.lower;
				signalFactor = signalScore.upper;
				resultsPrefix3 += "\t" + Utils.rounded(signalScore.lower) + "\t" + Utils.rounded(signalScore.upper);
				limitRange += ", s=" + Utils.rounded(signalScore.lower) + "-" + Utils.rounded(signalScore.upper);
			}
			else
			{
				signalScore = null;
				resultsPrefix3 += "\t0\t0";
				lowerSignalFactor = signalFactor = 0;
			}

			// Store all the results
			final ArrayList<MultiPathFitResults> results = new ArrayList<MultiPathFitResults>(
					BenchmarkSpotFit.fitResults.size());
			final List<MultiPathFitResults> syncResults = Collections.synchronizedList(results);

			// This could be multi-threaded ...
			final int nThreads = getThreads(BenchmarkSpotFit.fitResults.size());
			final BlockingQueue<Job> jobs = new ArrayBlockingQueue<Job>(nThreads * 2);
			final List<FitResultsWorker> workers = new LinkedList<FitResultsWorker>();
			final List<Thread> threads = new LinkedList<Thread>();
			for (int i = 0; i < nThreads; i++)
			{
				final FitResultsWorker worker = new FitResultsWorker(jobs, syncResults, matchDistance, distanceScore,
						signalScore);
				final Thread t = new Thread(worker);
				workers.add(worker);
				threads.add(t);
				t.start();
			}

			totalProgress = BenchmarkSpotFit.fitResults.size();
			stepProgress = Utils.getProgressInterval(totalProgress);
			progress = 0;
			for (Entry<Integer, FilterCandidates> entry : BenchmarkSpotFit.fitResults.entrySet())
			{
				put(jobs, entry);
			}
			// Finish all the worker threads by passing in a null job
			for (int i = 0; i < threads.size(); i++)
			{
				put(jobs, null);
			}

			// Wait for all to finish
			for (int i = 0; i < threads.size(); i++)
			{
				try
				{
					threads.get(i).join();
					matches += workers.get(i).matches;
					totalResults += workers.get(i).total;
				}
				catch (InterruptedException e)
				{
					e.printStackTrace();
				}
			}
			threads.clear();
			IJ.showProgress(1);
			IJ.showStatus("");

			resultsList = results.toArray(new MultiPathFitResults[results.size()]);
		}

		// In case a previous run was interrupted
		if (resultsList != null)
		{
			resetFailCount(resultsList);

			// XXX Clone this for use in debugging
			clonedResultsList = new MultiPathFitResults[resultsList.length];
			for (int i = 0; i < clonedResultsList.length; i++)
				clonedResultsList[i] = resultsList[i].clone();
		}

		return resultsList;
	}

	private void put(BlockingQueue<Job> jobs, Entry<Integer, FilterCandidates> entry)
	{
		try
		{
			jobs.put(new Job(entry));
		}
		catch (InterruptedException e)
		{
			throw new RuntimeException("Unexpected interruption", e);
		}
	}

	private HashMap<Integer, IdPeakResult[]> getCoordinates(List<PeakResult> list)
	{
		final HashMap<Integer, IdPeakResult[]> coords = new HashMap<Integer, IdPeakResult[]>();
		if (list.size() > 0)
		{
			// Do not use HashMap directly to build the coords object since there 
			// will be many calls to getEntry(). Instead sort the results and use 
			// a new list for each time point
			Collections.sort(list);

			int last = -1;
			int id = 0;
			ArrayList<PeakResult> tmp = new ArrayList<PeakResult>();
			// Add the results to the lists
			for (PeakResult p : list)
			{
				if (last != p.peak)
				{
					if (!tmp.isEmpty())
					{
						coords.put(last, tmp.toArray(new IdPeakResult[tmp.size()]));
					}
					id = 0;
				}
				last = p.peak;
				tmp.add(new IdPeakResult(id++, p));
			}

			if (!tmp.isEmpty())
			{
				coords.put(last, tmp.toArray(new IdPeakResult[tmp.size()]));
			}
		}
		return coords;
	}

	private static IdPeakResult[] EMPTY = new IdPeakResult[0];

	private static IdPeakResult[] getCoordinates(HashMap<Integer, IdPeakResult[]> coords, Integer t)
	{
		final IdPeakResult[] tmp = coords.get(t);
		return (tmp == null) ? EMPTY : tmp;
	}

	/**
	 * Score the new results in the fit result
	 *
	 * @param fitResult
	 *            the fit result
	 * @param resultGrid
	 *            the result grid
	 * @param matchDistance
	 *            the match distance
	 * @param distanceScore
	 *            the distance score
	 * @param signalScore
	 *            the signal score
	 * @param matched
	 *            array of actual results that have been matched
	 * @return true, if the fit status was ok
	 */
	private boolean score(gdsc.smlm.results.filter.MultiPathFitResult.FitResult fitResult, ResultGridManager resultGrid,
			double matchDistance, RampedScore distanceScore, RampedScore signalScore, boolean[] matched)
	{
		if (fitResult != null && fitResult.status == 0)
		{
			// Get the new results
			for (int i = 0; i < fitResult.results.length; i++)
			{
				final BasePreprocessedPeakResult peak = (BasePreprocessedPeakResult) fitResult.results[i];
				peak.setAssignments(null);
				if (!peak.isNewResult())
					continue;

				// Compare to actual results
				// We do this using the ResultGridManager to generate a sublist to score against
				final PeakResult[] actual = resultGrid.getPeakResultNeighbours((int) peak.getX(), (int) peak.getY());
				if (actual.length == 0)
					continue;

				final ArrayList<ResultAssignment> assignments = new ArrayList<ResultAssignment>();
				for (int j = 0; j < actual.length; j++)
				{
					final double d2 = actual[j].distance2(peak.getX(), peak.getY());
					if (d2 <= matchDistance)
					{
						final double distance = Math.sqrt(d2);
						final double signalFactor = BenchmarkSpotFit.getSignalFactor(peak.getSignal(),
								actual[j].getSignal());

						// Score ...
						double score = distanceScore.score(distance);
						if (signalScore != null)
						{
							score *= signalScore.score(signalFactor);
						}
						if (score != 0)
						{
							final int id = ((IdPeakResult) actual[j]).id;
							assignments.add(new CustomResultAssignment(id, distance, score, signalFactor, actual[j]));

							// Accumulate for each actual result
							if (!matched[id])
							{
								matched[id] = true;
								// Depth is stored in the error field
								depthFitStats.add(actual[j].error);
							}

							// Accumulate for all possible matches						
							signalFactorStats.add(signalFactor);
							// Store the match distance in nm
							distanceStats.add(distance * simulationParameters.a);
						}
					}
				}

				// Save 
				if (!assignments.isEmpty())
					peak.setAssignments(assignments.toArray(new ResultAssignment[assignments.size()]));
			}

			return true;
		}
		return false;
	}

	private boolean showDialog()
	{
		GenericDialog gd = new GenericDialog(TITLE);
		gd.addHelp(About.HELP_URL);

		double signal = simulationParameters.minSignal;
		if (simulationParameters.maxSignal > signal)
		{
			signal += simulationParameters.maxSignal;
			signal *= 0.5;
		}
		double pSignal = CreateData.getPrecisionN(simulationParameters.a, simulationParameters.s, signal,
				simulationParameters.b2, simulationParameters.emCCD);
		double pLSE = PeakResult.getPrecisionX(simulationParameters.a, simulationParameters.s, signal,
				simulationParameters.b2, simulationParameters.emCCD);
		double pMLE = PeakResult.getMLPrecisionX(simulationParameters.a, simulationParameters.s, signal,
				simulationParameters.b2, simulationParameters.emCCD);
		String msg = String.format(
				"%d results, %d True-Positives\nExpected signal = %.3f +/- %.3f\nExpected X precision = %.3f (LSE), %.3f (MLE)",
				totalResults, matches, signal, pSignal, pLSE, pMLE);
		FilterResult best = getBestResult();
		if (best != null)
		{
			msg += String.format("\nCurrent Best=%s, FailCount=%d, Range=%d", Utils.rounded(best.score), best.failCount,
					best.failCountRange);
		}
		gd.addMessage(msg);

		gd.addSlider("Fail_count", 0, 20, failCount);
		gd.addSlider("Fail_count_range", 0, 5, failCountRange);
		gd.addSlider("Residuals_threshold", 0, 1, residualsThreshold);
		gd.addCheckbox("Reset", reset);
		gd.addCheckbox("Show_table", showResultsTable);
		gd.addCheckbox("Show_summary", showSummaryTable);
		gd.addCheckbox("Clear_tables", clearTables);
		gd.addSlider("Summary_top_n", 0, 20, summaryTopN);
		gd.addNumericField("Summary_depth (nm)", summaryDepth, 0);
		gd.addSlider("Plot_top_n", 0, 20, plotTopN);
		gd.addCheckbox("Save_best_filter", saveBestFilter);
		gd.addCheckbox("Save_template", saveTemplate);
		gd.addCheckbox("Calculate_sensitivity", calculateSensitivity);
		gd.addSlider("Delta", 0.01, 1, delta);
		gd.addChoice("Criteria", COLUMNS, COLUMNS[criteriaIndex]);
		gd.addNumericField("Criteria_limit", criteriaLimit, 4);
		gd.addChoice("Score", COLUMNS, COLUMNS[scoreIndex]);
		gd.addMessage(String.format("Fitting match distance = %s nm; signal factor = %s",
				Utils.rounded(BenchmarkSpotFit.distanceInPixels * simulationParameters.a),
				Utils.rounded(BenchmarkSpotFit.signalFactor)));
		gd.addSlider("Upper_match_distance (%)", 0, 100, upperMatchDistance);
		gd.addSlider("Partial_match_distance (%)", 0, 100, partialMatchDistance);
		gd.addSlider("Upper_signal_factor (%)", 0, 100, upperSignalFactor);
		gd.addSlider("Partial_signal_factor (%)", 0, 100, partialSignalFactor);
		if (!simulationParameters.fixedDepth)
			gd.addCheckbox("Depth_recall_analysis", depthRecallAnalysis);
		gd.addCheckbox("Score_analysis", scoreAnalysis);
		gd.addCheckbox("Evolve", evolve);
		gd.addSlider("Step_search", 0, 4, stepSearch);
		gd.addStringField("Title", resultsTitle, 20);

		gd.showDialog();

		if (gd.wasCanceled() || !readDialog(gd))
			return false;

		if (showResultsTable || showSummaryTable)
		{
			gd = new GenericDialog(TITLE);
			gd.addHelp(About.HELP_URL);

			gd.addMessage("Select the results:");
			for (int i = 0; i < COLUMNS.length; i++)
				gd.addCheckbox(COLUMNS[i], showColumns[i]);
			gd.showDialog();

			if (gd.wasCanceled())
				return false;

			for (int i = 0; i < COLUMNS.length; i++)
				showColumns[i] = gd.getNextBoolean();

			requireIntegerResults = false;
			for (int i = 0; i < 7; i++)
			{
				if (showColumns[i])
				{
					requireIntegerResults = true;
					break;
				}
			}
		}

		// We may have to read the results again if the ranking option has changed
		if (lastPartialMatchDistance != partialMatchDistance || lastUpperMatchDistance != upperMatchDistance ||
				lastPartialSignalFactor != partialSignalFactor || lastUpperSignalFactor != upperSignalFactor)
			readResults();

		return true;
	}

	private boolean readDialog(GenericDialog gd)
	{
		failCount = (int) Math.abs(gd.getNextNumber());
		failCountRange = (int) Math.abs(gd.getNextNumber());
		residualsThreshold = Math.abs(gd.getNextNumber());
		reset = gd.getNextBoolean();
		showResultsTable = gd.getNextBoolean();
		showSummaryTable = gd.getNextBoolean();
		clearTables = gd.getNextBoolean();
		summaryTopN = (int) Math.abs(gd.getNextNumber());
		summaryDepth = Math.abs(gd.getNextNumber());
		plotTopN = (int) Math.abs(gd.getNextNumber());
		saveBestFilter = gd.getNextBoolean();
		saveTemplate = gd.getNextBoolean();
		calculateSensitivity = gd.getNextBoolean();
		delta = gd.getNextNumber();
		criteriaIndex = gd.getNextChoiceIndex();
		criteriaLimit = gd.getNextNumber();
		scoreIndex = gd.getNextChoiceIndex();
		upperMatchDistance = Math.abs(gd.getNextNumber());
		partialMatchDistance = Math.abs(gd.getNextNumber());
		upperSignalFactor = Math.abs(gd.getNextNumber());
		partialSignalFactor = Math.abs(gd.getNextNumber());
		if (!simulationParameters.fixedDepth)
			depthRecallAnalysis = gd.getNextBoolean();
		scoreAnalysis = gd.getNextBoolean();
		evolve = gd.getNextBoolean();
		stepSearch = (int) Math.abs(gd.getNextNumber());
		resultsTitle = gd.getNextString();

		resultsPrefix = BenchmarkSpotFit.resultPrefix + "\t" + resultsTitle + "\t";
		resultsPrefix2 = "\t" + failCount;
		if (!Utils.isNullOrEmpty(resultsTitle))
			limitFailCount = resultsTitle + ", ";
		else
			limitFailCount = "";
		limitFailCount += "f=" + failCount;
		if (failCountRange > 0)
		{
			resultsPrefix2 += "-" + (failCount + failCountRange);
			limitFailCount += "-" + (failCount + failCountRange);
		}

		// Check there is one output
		if (!showResultsTable && !showSummaryTable && !calculateSensitivity && plotTopN < 1 && !saveBestFilter)
		{
			IJ.error(TITLE, "No output selected");
			return false;
		}

		// Check arguments
		try
		{
			Parameters.isAboveZero("Delta", delta);
			Parameters.isBelow("Delta", delta, 1);
			Parameters.isEqualOrBelow("Partial match distance", partialMatchDistance, upperMatchDistance);
			Parameters.isEqualOrBelow("Partial signal factor", partialSignalFactor, upperSignalFactor);
		}
		catch (IllegalArgumentException e)
		{
			IJ.error(TITLE, e.getMessage());
			return false;
		}

		invertCriteria = requiresInversion(criteriaIndex);
		minCriteria = (invertCriteria) ? -criteriaLimit : criteriaLimit;
		invertScore = requiresInversion(scoreIndex);

		return !gd.invalidNumber();
	}

	/**
	 * Run different filtering methods on a set of labelled peak results outputting performance statistics on the
	 * success of
	 * the filter to an ImageJ table.
	 * <p>
	 * If the peak result original value is set to 1 it is considered a true peak, 0 for a false peak. Filtering is done
	 * using e.g. SNR threshold, Precision thresholds, etc. The statistics reported are shown in a table, e.g.
	 * precision, Jaccard, F-score.
	 * <p>
	 * For each filter set a plot is shown of the score verses the filter value, thus filters should be provided in
	 * ascending numerical order otherwise they are sorted.
	 * 
	 * @param resultsList
	 * @param filterSets
	 */
	private void analyse(List<FilterSet> filterSets)
	{
		if (reset)
			scores.clear();

		createResultsWindow();
		plots = new ArrayList<NamedPlot>(plotTopN);
		bestFilter = new HashMap<String, FilterScore>();
		bestFilterOrder = new LinkedList<String>();

		startTimer();
		IJ.showStatus("Analysing filters ...");
		int setNumber = 0;
		for (FilterSet filterSet : filterSets)
		{
			setNumber++;
			if (run(filterSet, setNumber) < 0)
				break;
		}
		stopTimer();
		IJ.showProgress(1);
		IJ.showStatus("");

		if (Utils.isInterrupted())
			return;

		if (bestFilter.isEmpty())
		{
			IJ.log("Warning: No filters pass the criteria");
			return;
		}

		List<FilterScore> filters = new ArrayList<FilterScore>(bestFilter.values());
		if (showSummaryTable || saveBestFilter)
			Collections.sort(filters);

		FractionClassificationResult topFilterClassificationResult = null;
		ArrayList<FractionalAssignment[]> topFilterResults = null;
		String topFilterSummary = null;
		if (showSummaryTable || saveTemplate)
		{
			createSummaryWindow();
			int n = 0;
			final double range = (summaryDepth / simulationParameters.a) * 0.5;
			int np = 0;
			for (double depth : depthStats)
			{
				if (Math.abs(depth) < range)
					np++;
			}
			for (FilterScore fs : filters)
			{
				final ArrayList<FractionalAssignment[]> list = new ArrayList<FractionalAssignment[]>(
						resultsList.length);
				final FractionClassificationResult r = scoreFilter(fs.filter, resultsList, list);
				final StringBuilder sb = createResult(fs.filter, r);

				if (topFilterResults == null)
				{
					topFilterResults = list;
					topFilterClassificationResult = r;
				}

				// Show the recall at the specified depth. Sum the distance and signal factor of all scored spots.
				int scored = 0;
				double tp = 0, d = 0, sf = 0;
				for (FractionalAssignment[] assignments : list)
				{
					if (assignments == null)
						continue;
					for (int i = 0; i < assignments.length; i++)
					{
						final CustomFractionalAssignment c = (CustomFractionalAssignment) assignments[i];
						if (Math.abs(c.peak.error) <= range)
							tp += c.getScore();
						d += c.getDistance();
						sf += c.sf;
					}
					scored += assignments.length;
				}

				sb.append('\t').append(Utils.rounded((double) tp / np)).append('\t').append(Utils.rounded(d / scored))
						.append('\t').append(Utils.rounded(sf / scored)).append('\t');
				if (fs.atLimit)
					sb.append('Y');

				final String text = sb.toString();
				if (topFilterSummary == null)
				{
					topFilterSummary = text;
					if (!showSummaryTable)
						break;
				}

				if (isHeadless)
					IJ.log(text);
				else
					summaryWindow.append(text);
				n++;
				if (summaryTopN > 0 && n >= summaryTopN)
					break;
			}
			// Add a spacer to the summary table if we have multiple results
			if (n > 1 && showSummaryTable)
			{
				if (isHeadless)
					IJ.log("");
				else
					summaryWindow.append("");
			}
		}

		DirectFilter bestFilter = filters.get(0).filter;
		if (saveBestFilter)
			saveFilter(bestFilter);

		if (topFilterClassificationResult == null)
		{
			topFilterResults = new ArrayList<FractionalAssignment[]>(resultsList.length);
			topFilterClassificationResult = scoreFilter(bestFilter, resultsList, topFilterResults);
		}
		scores.add(new FilterResult(bestFilter, getScore(topFilterClassificationResult), failCount, failCountRange));

		if (saveTemplate)
			saveTemplate(topFilterSummary);

		showPlots();
		calculateSensitivity();
		topFilterResults = depthAnalysis(topFilterResults, bestFilter);
		scoreAnalysis(topFilterResults, bestFilter);

		wo.tile();
	}

	private void startTimer()
	{
		currentTime = System.currentTimeMillis();
	}

	private void stopTimer()
	{
		totalTime += System.currentTimeMillis() - currentTime;
	}

	private int countFilters(List<FilterSet> filterSets)
	{
		int count = 0;
		for (FilterSet filterSet : filterSets)
			count += filterSet.size();
		return count;
	}

	private void showPlots()
	{
		if (plots.isEmpty())
			return;

		// Display the top N plots
		int[] list = new int[plots.size()];
		int i = 0;
		for (NamedPlot p : plots)
		{
			Plot2 plot = new Plot2(p.name, p.xAxisName, COLUMNS[scoreIndex], p.xValues, p.yValues);
			plot.setLimits(p.xValues[0], p.xValues[p.xValues.length - 1], 0, 1);
			plot.setColor(Color.RED);
			plot.draw();
			plot.setColor(Color.BLUE);
			plot.addPoints(p.xValues, p.yValues, Plot2.CROSS);
			PlotWindow plotWindow = Utils.display(p.name, plot);
			list[i++] = plotWindow.getImagePlus().getID();
		}
		new WindowOrganiser().tileWindows(list);
	}

	private void calculateSensitivity()
	{
		if (!calculateSensitivity)
			return;
		if (!bestFilter.isEmpty())
		{
			IJ.showStatus("Calculating sensitivity ...");
			createSensitivityWindow();

			int currentIndex = 0;
			for (String type : bestFilterOrder)
			{
				IJ.showProgress(currentIndex++, bestFilter.size());

				DirectFilter filter = bestFilter.get(type).filter;

				FractionClassificationResult s = scoreFilter(filter, resultsList);
				s = getOriginalScore(s);

				String message = type + "\t\t\t" + Utils.rounded(s.getJaccard(), 4) + "\t\t" +
						Utils.rounded(s.getPrecision(), 4) + "\t\t" + Utils.rounded(s.getRecall(), 4);

				if (isHeadless)
				{
					IJ.log(message);
				}
				else
				{
					sensitivityWindow.append(message);
				}

				// List all the parameters that can be adjusted.
				final int parameters = filter.getNumberOfParameters();
				for (int index = 0; index < parameters; index++)
				{
					// For each parameter compute as upward + downward delta and get the average gradient
					DirectFilter higher = (DirectFilter) filter.adjustParameter(index, delta);
					DirectFilter lower = (DirectFilter) filter.adjustParameter(index, -delta);

					FractionClassificationResult sHigher = scoreFilter(higher, resultsList);
					sHigher = getOriginalScore(sHigher);
					FractionClassificationResult sLower = scoreFilter(lower, resultsList);
					sLower = getOriginalScore(sLower);

					StringBuilder sb = new StringBuilder();
					sb.append("\t").append(filter.getParameterName(index)).append("\t");
					sb.append(Utils.rounded(filter.getParameterValue(index), 4)).append("\t");

					double dx1 = higher.getParameterValue(index) - filter.getParameterValue(index);
					double dx2 = filter.getParameterValue(index) - lower.getParameterValue(index);
					addSensitivityScore(sb, s.getJaccard(), sHigher.getJaccard(), sLower.getJaccard(), dx1, dx2);
					addSensitivityScore(sb, s.getPrecision(), sHigher.getPrecision(), sLower.getPrecision(), dx1, dx2);
					addSensitivityScore(sb, s.getRecall(), sHigher.getRecall(), sLower.getRecall(), dx1, dx2);

					if (isHeadless)
					{
						IJ.log(sb.toString());
					}
					else
					{
						sensitivityWindow.append(sb.toString());
					}
				}
			}

			String message = "-=-=-=-";
			if (isHeadless)
			{
				IJ.log(message);
			}
			else
			{
				sensitivityWindow.append(message);
			}

			IJ.showProgress(1);
			IJ.showStatus("");
		}
	}

	private void addSensitivityScore(StringBuilder sb, double s, double s1, double s2, double dx1, double dx2)
	{
		// Use absolute in case this is not a local maximum. We are mainly interested in how
		// flat the curve is at this point in relation to parameter changes.
		double abs = 0, dydx = 0;
		int count = 0;
		if (dx1 > 0)
		{
			double abs1 = Math.abs(s - s1);
			double dydx1 = abs1 / dx1;
			abs += abs1;
			dydx += dydx1;
			count++;
		}
		if (dx2 > 0)
		{
			double abs2 = Math.abs(s - s2);
			double dydx2 = abs2 / dx2;
			abs += abs2;
			dydx += dydx2;
			count++;
		}

		double relativeSensitivity = 0, sensitivity = 0;
		if (count != 0)
		{
			relativeSensitivity = abs / count;
			sensitivity = dydx / count;
		}

		sb.append(Utils.rounded(relativeSensitivity, 4)).append("\t");
		sb.append(Utils.rounded(sensitivity, 4)).append("\t");
	}

	private void createResultsWindow()
	{
		if (!showResultsTable)
			return;

		if (isHeadless)
		{
			IJ.log(createResultsHeader(false));
		}
		else
		{
			if (resultsWindow == null || !resultsWindow.isShowing())
			{
				String header = createResultsHeader(false);
				resultsWindow = new TextWindow(TITLE + " Results", header, "", 900, 300);
			}
			if (clearTables)
				resultsWindow.getTextPanel().clear();
		}
	}

	private void createSummaryWindow()
	{
		if (!showSummaryTable)
			return;

		if (isHeadless)
		{
			IJ.log(createResultsHeader(true));
		}
		else
		{
			if (summaryWindow == null || !summaryWindow.isShowing())
			{
				String header = createResultsHeader(true);
				summaryWindow = new TextWindow(TITLE + " Summary", header, "", 900, 300);
			}
			if (clearTables)
				summaryWindow.getTextPanel().clear();
		}
	}

	private void createGAWindow()
	{
		if (isHeadless)
		{
			String header = createResultsHeader(false);
			header += "\tIteration";
			IJ.log(header);
		}
		else
		{
			if (gaWindow == null || !gaWindow.isShowing())
			{
				String header = createResultsHeader(false);
				header += "\tIteration";
				gaWindow = new TextWindow(TITLE + " Evolution", header, "", 900, 300);
			}
			if (clearTables)
				gaWindow.getTextPanel().clear();
		}
	}

	private String createResultsHeader(boolean summary)
	{
		StringBuilder sb = new StringBuilder(BenchmarkSpotFit.tablePrefix);
		sb.append("\tTitle\tName\tFail\tLower D (nm)\tUpper D (nm)\tLower factor\tUpper factor");

		for (int i = 0; i < COLUMNS.length; i++)
			if (showColumns[i])
				sb.append("\t").append(COLUMNS[i]);

		if (summary)
			sb.append("\tDepth Recall\tDistance\tSignal Factor\tAt limit");
		return sb.toString();
	}

	private void createSensitivityWindow()
	{
		if (isHeadless)
		{
			IJ.log(createSensitivityHeader());
		}
		else
		{
			if (sensitivityWindow == null || !sensitivityWindow.isShowing())
			{
				String header = createSensitivityHeader();
				sensitivityWindow = new TextWindow(TITLE + " Sensitivity", header, "", 900, 300);
			}
		}
	}

	private String createSensitivityHeader()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Filter\t");
		sb.append("Param\t");
		sb.append("Value\t");
		sb.append("J Sensitivity (delta)\t");
		sb.append("J Sensitivity (unit)\t");
		sb.append("P Sensitivity (delta)\t");
		sb.append("P Sensitivity (unit)\t");
		sb.append("R Sensitivity (delta)\t");
		sb.append("R Sensitivity (unit)\t");
		return sb.toString();
	}

	private int run(FilterSet filterSet, int setNumber)
	{
		// Check if the filters are the same so allowing optimisation
		final boolean allSameType = filterSet.allSameType();

		this.ga_resultsList = resultsList;
		Chromosome best = null;

		if (evolve && allSameType)
		{
			// Collect parameters for the genetic algorithm
			stopTimer();

			createGAWindow();

			final Filter filter = filterSet.getFilters().get(0);
			double[] stepSize = filter.mutationStepRange().clone();
			double[] upper = filter.upperLimit();
			// Ask the user for the mutation step parameters.
			GenericDialog gd = new GenericDialog(TITLE);
			String prefix = setNumber + "_";
			gd.addMessage("Configure the genetic algorithm for [" + setNumber + "] " + filterSet.getName());
			gd.addNumericField(prefix + "Population_size", populationSize, 0);
			gd.addNumericField(prefix + "Failure_limit", failureLimit, 0);
			gd.addNumericField(prefix + "Tolerance", tolerance, -1);
			gd.addNumericField(prefix + "Converged_count", convergedCount, 0);
			gd.addSlider(prefix + "Mutation_rate", 0.05, 1, mutationRate);
			gd.addSlider(prefix + "Crossover_rate", 0.05, 1, crossoverRate);
			gd.addSlider(prefix + "Mean_children", 0.05, 3, meanChildren);
			gd.addSlider(prefix + "Selection_fraction", 0.05, 0.5, selectionFraction);
			gd.addCheckbox(prefix + "Ramped_selection", rampedSelection);
			gd.addCheckbox(prefix + "Strict_fitness", strictFitness);
			gd.addCheckbox(prefix + "Save_option", saveOption);

			gd.addMessage("Configure the step size for each parameter");
			int[] indices = filter.getChromosomeParameters();
			final boolean wasExpanded = wasExpanded(setNumber);
			for (int j = 0; j < indices.length; j++)
			{
				// Do not mutate parameters that were not expanded, i.e. the input did not vary them.
				final double step = (wasExpanded && wasNotExpanded(setNumber, indices[j])) ? 0 : stepSize[j] * delta;
				gd.addNumericField(getDialogName(prefix, filter.getParameterName(indices[j])), step, 2);
			}

			gd.showDialog();

			startTimer();

			if (!gd.wasCanceled())
			{
				populationSize = (int) Math.abs(gd.getNextNumber());
				if (populationSize < 10)
					populationSize = 10;
				failureLimit = (int) Math.abs(gd.getNextNumber());
				tolerance = Math.abs(gd.getNextNumber());
				convergedCount = (int) gd.getNextNumber(); // Allow negatives
				mutationRate = Math.abs(gd.getNextNumber());
				crossoverRate = Math.abs(gd.getNextNumber());
				meanChildren = Math.abs(gd.getNextNumber());
				selectionFraction = Math.abs(gd.getNextNumber());
				rampedSelection = gd.getNextBoolean();
				strictFitness = gd.getNextBoolean();
				saveOption = gd.getNextBoolean();

				for (int j = 0; j < indices.length; j++)
					stepSize[j] = Math.abs(gd.getNextNumber());

				// Create the genetic algorithm
				RandomDataGenerator random = new RandomDataGenerator(new Well44497b());
				SimpleMutator mutator = new SimpleMutator(random, mutationRate);
				// Override the settings with the step length, a min of zero and the configured upper
				mutator.overrideChromosomeSettings(stepSize, new double[stepSize.length], upper);
				Recombiner recombiner = new SimpleRecombiner(random, crossoverRate, meanChildren);
				SelectionStrategy selectionStrategy;
				// If the initial population is huge ensure that the first selection culls to the correct size
				final int selectionMax = (int) (selectionFraction * populationSize);
				if (rampedSelection)
					selectionStrategy = new RampedSelectionStrategy(random, selectionFraction, selectionMax);
				else
					selectionStrategy = new SimpleSelectionStrategy(random, selectionFraction, selectionMax);
				ToleranceChecker ga_checker = new InterruptChecker(tolerance, tolerance * 1e-3, convergedCount);
				ga_population = new Population(filterSet.getFilters());
				ga_population.setPopulationSize(populationSize);
				ga_population.setFailureLimit(failureLimit);
				selectionStrategy.setTracker(this);

				// Evolve
				ga_statusPrefix = "Evolving [" + setNumber + "] " + filterSet.getName() + " ... ";
				ga_iteration = 0;
				ga_population.setTracker(this);
				best = ga_population.evolve(mutator, recombiner, this, selectionStrategy, ga_checker);

				if (best != null)
				{
					// Now update the filter set for final assessment
					filterSet = new FilterSet(filterSet.getName(), populationToFilters(ga_population.getIndividuals()));

					// Option to save the filters
					if (saveOption)
						saveFilterSet(filterSet, setNumber);
				}
			}
		}

		IJ.showStatus("Analysing [" + setNumber + "] " + filterSet.getName() + " ...");

		final BufferedTextWindow tw = (showResultsTable && resultsWindow != null)
				? new BufferedTextWindow(resultsWindow) : null;
		if (tw != null)
			tw.setIncrement(Integer.MAX_VALUE);

		// If the filters were expanded we can do a step search from the initial optimum using the increment
		if (!evolve && stepSearch != 0 && allSameType && wasExpanded(setNumber))
		{
			// Evaluate all the filters and find the best
			ScoreResult max = null;
			boolean criteriaPassed = false;

			ScoreResult[] scoreResults = scoreFilters(filterSet, showResultsTable);
			if (scoreResults == null)
				return -1;

			for (int index = 0; index < scoreResults.length; index++)
			{
				final ScoreResult result = scoreResults[index];

				addToResultsWindow(tw, result);

				// Avoid null pointer
				if (max == null)
				{
					max = result;
					criteriaPassed = (result.criteria >= minCriteria);
					continue;
				}

				// Check if the criteria are achieved
				if (result.criteria >= minCriteria)
				{
					criteriaPassed = true;

					// Check if the score is better
					int compare = Double.compare(max.score, result.score);
					if (compare < 0)
					{
						max = result;
					}
					// If the same then check the criteria
					else if (compare == 0)
					{
						compare = Double.compare(max.criteria, result.criteria);
						if (compare < 0)
						{
							max = result;
						}
						// If equal criteria then if the same type get the filter with the strongest params
						else if (compare == 0 && allSameType && max.filter.weakest(result.filter) < 0)
						{
							max = result;
						}
					}
				}
				// If the max filter has not achieved the criteria then store the best
				else if (!criteriaPassed)
				{
					int compare = Double.compare(max.criteria, result.criteria);
					if (compare < 0)
					{
						max = result;
					}
					// If equal criteria then if the same type get the filter with the strongest params
					else if (compare == 0 && allSameType && result.criteria > 0 &&
							max.filter.weakest(result.filter) < 0)
					{
						max = result;
					}
				}
			}

			if (max != null)
			{
				final int set = setNumber - 1;
				// Force this if we are using smaller steps. 
				boolean doSearch = (stepSearch > 1);
				if (!doSearch)
				{
					// Test if the best filter is at the limit of the enumeration
					// Otherwise we will walk around the space we have already covered with a step size of 1.
					for (int j = 0; j < lowerLimit[set].length; j++)
					{
						if (increment[set][j] > 0)
						{
							final double value = max.filter.getParameterValue(j);
							if ((value <= lowerLimit[set][j] && value > 0) || value >= upperLimit[set][j])
							{
								doSearch = true;
								break;
							}
						}
					}
				}

				// Iterative step search until the surrounding positions are not an improvement
				// Limit the iterations in case of a problem.
				int iteration = 0;
				while (doSearch && iteration < 20)
				{
					iteration++;
					//System.out.printf("[%d] %s = %.3f (%.3f)\n", iteration, max.filter.getName(), max.score,
					//		max.criteria);

					IJ.showStatus(
							"Step search [" + setNumber + "] " + filterSet.getName() + " ... Iteration=" + iteration);

					// Create a new filter set surrounding the top filter
					final DirectFilter oldMaxFilter = max.filter;
					ArrayList<Filter> filters = new ArrayList<Filter>();
					filters.add(max.filter);
					final int n = lowerLimit[set].length;
					for (int i = 0; i < n; i++)
					{
						if (increment[set][i] > 0)
						{
							for (int k = filters.size(); k-- > 0;)
							{
								Filter f = filters.get(k);
								double[] parameters = new double[n];
								for (int j = 0; j < n; j++)
									parameters[j] = f.getParameterValue(j);

								final double d = parameters[i];
								for (int step = 1; step <= stepSearch; step++)
								{
									addFilters(filters, f, parameters, d, i, step * increment[set][i] / stepSearch);
								}
							}
						}
					}
					FilterSet newSet = new FilterSet(filters);

					// Score the filters
					scoreResults = scoreFilters(newSet, showResultsTable);
					if (scoreResults == null)
						return -1;

					for (int index = 0; index < scoreResults.length; index++)
					{
						final ScoreResult result = scoreResults[index];

						addToResultsWindow(tw, result);

						// Check if the criteria are achieved
						if (result.criteria >= minCriteria)
						{
							criteriaPassed = true;

							// Check if the score is better
							int compare = Double.compare(max.score, result.score);
							if (compare < 0)
							{
								max = result;
							}
							// If the same then check the criteria
							else if (compare == 0)
							{
								compare = Double.compare(max.criteria, result.criteria);
								if (compare < 0)
								{
									max = result;
								}
								// If equal criteria then if the same type get the filter with the strongest params
								else if (compare == 0 && allSameType && max.filter.weakest(result.filter) < 0)
								{
									max = result;
								}
							}
						}
						// If the max filter has not achieved the criteria then store the best
						else if (!criteriaPassed)
						{
							int compare = Double.compare(max.criteria, result.criteria);
							if (compare < 0)
							{
								max = result;
							}
							// If equal criteria then if the same type get the filter with the strongest params
							else if (compare == 0 && allSameType && result.criteria > 0 &&
									max.filter.weakest(result.filter) < 0)
							{
								max = result;
							}
						}
					}

					// Check if the top filter has changed to continue the search
					doSearch = !max.filter.equals(oldMaxFilter);
				}
			}

			// Allow the re-evaluation of all the filters to be skipped
			best = max.filter;
		}

		// Do not support plotting if we used optimisation
		double[] xValues = (best != null || isHeadless || (plotTopN == 0)) ? null : new double[filterSet.size()];
		double[] yValues = (xValues == null) ? null : new double[xValues.length];
		ScoreResult max = null;
		boolean criteriaPassed = false;

		// Final evaluation does not need to assess all the filters if we have run optimisation.
		// It can just assess the top 1 required for the summary.
		if (best != null)
		{
			// Only assess the top 1 filter for the summary
			List<Filter> list = new ArrayList<Filter>();
			list.add((DirectFilter) best);
			filterSet = new FilterSet(filterSet.getName(), list);
		}

		// Score the filters and report the results if configured.
		// Note that count and total may have changed after running the genetic algorithm
		// so use fractional progress.

		ScoreResult[] scoreResults = scoreFilters(filterSet, showResultsTable);
		if (scoreResults == null)
			return -1;

		for (int index = 0; index < scoreResults.length; index++)
		{
			final ScoreResult result = scoreResults[index];

			addToResultsWindow(tw, result);

			if (xValues != null)
			{
				xValues[index] = result.filter.getNumericalValue();
				yValues[index] = result.score;
			}

			// Avoid null pointer
			if (max == null)
			{
				max = result;
				criteriaPassed = (result.criteria >= minCriteria);
				continue;
			}

			// XXX - Debug print statements 
			final boolean debugFilterChanges = false;

			// Check if the criteria are achieved
			if (result.criteria >= minCriteria)
			{
				criteriaPassed = true;

				// Check if the score is better
				int compare = Double.compare(max.score, result.score);
				if (compare < 0)
				{
					if (debugFilterChanges)
						System.out.printf("1. %f|%f => %f|%f\n", max.score, max.criteria, result.score,
								result.criteria);
					max = result;
				}
				// If the same then check the criteria
				else if (compare == 0)
				{
					compare = Double.compare(max.criteria, result.criteria);
					if (compare < 0)
					{
						if (debugFilterChanges)
							System.out.printf("2. %f|%f => %f|%f\n", max.score, max.criteria, result.score,
									result.criteria);
						max = result;
					}
					// If equal criteria then if the same type get the filter with the strongest params
					else if (compare == 0 && allSameType && max.filter.weakest(result.filter) < 0)
					{
						if (debugFilterChanges)
							System.out.printf("3. %f|%f => %f|%f\n", max.score, max.criteria, result.score,
									result.criteria);
						max = result;
					}
				}
			}
			// If the max filter has not achieved the criteria then store the best
			else if (!criteriaPassed)
			{
				int compare = Double.compare(max.criteria, result.criteria);
				if (compare < 0)
				{
					if (debugFilterChanges)
						System.out.printf("4. %f|%f => %f|%f\n", max.score, max.criteria, result.score,
								result.criteria);
					max = result;
				}
				// If equal criteria then if the same type get the filter with the strongest params
				else if (compare == 0 && allSameType && result.criteria > 0 && max.filter.weakest(result.filter) < 0)
				{
					if (debugFilterChanges)
						System.out.printf("5. %f|%f => %f|%f\n", max.score, max.criteria, result.score,
								result.criteria);
					max = result;
				}
			}
		}

		// Update the final results window given that we mainly use appendWidthoutUpdate(...) when adding data
		if (showResultsTable)
			resultsWindow.getTextPanel().updateDisplay();

		// Check the top filter against the limits
		boolean atLimit = false;
		if (allSameType)
		{
			if (max != null)
			{
				int[] indices = max.filter.getChromosomeParameters();
				StringBuilder sb = new StringBuilder();
				final int set = setNumber - 1;
				for (int j = 0; j < indices.length; j++)
				{
					final int p = indices[j];
					if (!wasNotExpanded(setNumber, p))
					{
						final double value = max.filter.getParameterValue(p);
						int c1 = Double.compare(value, lowerLimit[set][p]);
						if (c1 <= 0)
						{
							sb.append(" : ").append(max.filter.getParameterName(p)).append(" [")
									.append(Utils.rounded(value));
							if (c1 == -1)
								sb.append("<").append(Utils.rounded(lowerLimit[set][p]));
							sb.append("]");
						}
						else
						{
							int c2 = Double.compare(value, upperLimit[set][p]);
							if (c2 >= 0)
							{
								sb.append(" : ").append(max.filter.getParameterName(p)).append(" [")
										.append(Utils.rounded(value));
								if (c2 == 1)
									sb.append(">").append(Utils.rounded(upperLimit[set][p]));
								sb.append("]");
							}
						}
					}
				}
				if (sb.length() > 0)
				{
					atLimit = true;
					if (criteriaPassed)
					{
						Utils.log("Warning: Top filter (%s @ %s|%s) [%s] at the limit of the expanded range%s",
								max.filter.getName(), Utils.rounded((invertScore) ? -max.score : max.score),
								Utils.rounded((invertCriteria) ? -minCriteria : minCriteria),
								limitFailCount + limitRange, sb.toString());
					}
					else
					{
						Utils.log("Warning: Top filter (%s @ -|%s) [%s] at the limit of the expanded range%s",
								max.filter.getName(), Utils.rounded((invertCriteria) ? -max.criteria : max.criteria),
								limitFailCount + limitRange, sb.toString());
					}
				}
			}
		}

		// Note that max should never be null since this method is not run with an empty filter set

		// We may have no filters that pass the criteria
		String type = max.filter.getType();
		if (!criteriaPassed)
		{
			Utils.log("Warning: Filter does not pass the criteria: %s : Best = %s using %s", type,
					Utils.rounded((invertCriteria) ? -max.criteria : max.criteria), max.filter.getName());
			return 0;
		}

		boolean allowDuplicates = true; // This could be an option?

		// XXX - Commented out the requirement to be the same type to store for later analysis. 
		// This may break the code, however I think that all filter sets should be able to have a best filter
		// irrespective of whether they were the same type or not.
		//if (allSameType)
		//{
		FilterScore newFilterScore = new FilterScore(max.filter, max.score, max.criteria, atLimit);
		FilterScore filterScore = bestFilter.get(type);
		if (filterScore != null)
		{
			if (allowDuplicates)
			{
				// Duplicate type: create a unique key
				// Start at 2 to show it is the second one of the same type
				int n = 2;
				while (bestFilter.containsKey(type + n))
					n++;
				type += n;
				bestFilter.put(type, newFilterScore);
				bestFilterOrder.add(type);
			}
			else
			{
				// Replace
				if (newFilterScore.compareTo(filterScore) < 0)
					filterScore.update(max.filter, max.score, max.criteria, atLimit);
			}
		}
		else
		{
			bestFilter.put(type, newFilterScore);
			bestFilterOrder.add(type);
		}
		//}

		// Add spacer at end of each result set
		if (isHeadless)
		{
			if (showResultsTable && filterSet.size() > 1)
				IJ.log("");
		}
		else
		{
			if (showResultsTable && filterSet.size() > 1)
				resultsWindow.append("");

			if (plotTopN > 0 && xValues != null)
			{
				// Check the xValues are unique. Since the filters have been sorted by their
				// numeric value we only need to compare adjacent entries.
				boolean unique = true;
				for (int ii = 0; ii < xValues.length - 1; ii++)
				{
					if (xValues[ii] == xValues[ii + 1])
					{
						unique = false;
						break;
					}
				}
				String xAxisName = filterSet.getValueName();
				if (unique)
				{
					// Check the values all refer to the same property
					for (Filter filter : filterSet.getFilters())
					{
						if (!xAxisName.equals(filter.getNumericalValueName()))
						{
							unique = false;
							break;
						}
					}
				}
				if (!unique)
				{
					// If not unique then renumber them and use an arbitrary label
					xAxisName = "Filter";
					for (int ii = 0; ii < xValues.length; ii++)
						xValues[ii] = ii + 1;
				}

				String title = filterSet.getName();

				// Check if a previous filter set had the same name, update if necessary
				NamedPlot p = getNamedPlot(title);
				if (p == null)
					plots.add(new NamedPlot(title, xAxisName, xValues, yValues));
				else
					p.updateValues(xAxisName, xValues, yValues);

				if (plots.size() > plotTopN)
				{
					Collections.sort(plots);
					p = plots.remove(plots.size() - 1);
				}
			}
		}

		return 0;
	}

	private void addToResultsWindow(BufferedTextWindow tw, final ScoreResult result)
	{
		if (showResultsTable && result.text != null)
		{
			if (isHeadless)
			{
				IJ.log(result.text);
			}
			else
			{
				tw.append(result.text);
			}
		}
	}

	private void addFilters(ArrayList<Filter> filters, Filter f, double[] parameters, double value, int index,
			double step)
	{
		parameters[index] = value - step;
		if (parameters[index] >= 0) // Avoid negative parameters
			filters.add(f.create(parameters));
		parameters[index] = value + step;
		filters.add(f.create(parameters));
	}

	/**
	 * When the two filters have equal scores, select the filter using the filter parameters
	 * 
	 * @param filter1
	 * @param filter2
	 * @return The chosen filter (the one with the strongest parameters)
	 */
	public Filter selectFilter(Filter filter1, Filter filter2)
	{
		return (filter2.weakest(filter1) < 0) ? filter1 : filter2;
	}

	private String getDialogName(String prefix, String parameterName)
	{
		return prefix + parameterName.replace(" ", "_");
	}

	private double getCriteria(FractionClassificationResult s)
	{
		return getScore(s, criteriaIndex, invertCriteria);
	}

	private double getScore(FractionClassificationResult s)
	{
		return getScore(s, scoreIndex, invertScore);
	}

	private double getScore(FractionClassificationResult s, final int index, final boolean invert)
	{
		final double score = getScore(s, index);
		return (invert) ? -score : score;
	}

	private double getScore(FractionClassificationResult r, final int index)
	{
		// This order must match the COLUMNS order 
		switch (index)
		{
			case 0:
				return r.getPositives();
			case 1:
				return r.getNegatives();
			case 2:
				return simulationParameters.molecules - r.getPositives();
			case 3:
				return createIntegerResult(r).getPrecision();
			case 4:
				return createIntegerResult(r).getRecall();
			case 5:
				return createIntegerResult(r).getF1Score();
			case 6:
				return createIntegerResult(r).getJaccard();
			case 7:
				return r.getTP();
			case 8:
				return r.getFP();
			case 9:
				return r.getFN();
			case 10:
				return r.getPrecision();
			case 11:
				return r.getRecall();
			case 12:
				return r.getF1Score();
			case 13:
				return r.getJaccard();
		}
		return 0;
	}

	private boolean requiresInversion(final int index)
	{
		switch (index)
		{
			case 1: // FP
			case 2: // FN
			case 8: // fFP
			case 9: // fFN
				return true;

			default:
				return false;
		}
	}

	private NamedPlot getNamedPlot(String title)
	{
		for (NamedPlot p : plots)
			if (p.name.equals(title))
				return p;
		return null;
	}

	private double getMaximum(double[] values)
	{
		double max = values[0];
		for (int i = 1; i < values.length; i++)
		{
			if (values[i] > max)
			{
				max = values[i];
			}
		}
		return max;
	}

	/**
	 * Score the filter using the results list and the configured fail count.
	 *
	 * @param filter
	 *            the filter
	 * @param resultsList
	 *            the results list
	 * @return The score
	 */
	private FractionClassificationResult scoreFilter(DirectFilter filter, MultiPathFitResults[] resultsList)
	{
		return scoreFilter(filter, resultsList, null);
	}

	/**
	 * Score the filter using the results list and the configured fail count.
	 *
	 * @param filter
	 *            the filter
	 * @param resultsList
	 *            the results list
	 * @param allAssignments
	 *            all the assignments
	 * @return The score
	 */
	private FractionClassificationResult scoreFilter(DirectFilter filter, MultiPathFitResults[] resultsList,
			List<FractionalAssignment[]> allAssignments)
	{
		final MultiPathFilter multiPathFilter = createMPF(filter);

		// Note: We always use the subset method since fail counts have been accumulated when we read in the results.

		if (failCountRange == 0)
			return multiPathFilter.fractionScoreSubset(resultsList, failCount, simulationParameters.molecules,
					allAssignments);

		double tp = 0, fp = 0, fn = 0;
		int p = 0, n = 0;
		for (int i = 0; i <= failCountRange; i++)
		{
			final FractionClassificationResult r = multiPathFilter.fractionScoreSubset(resultsList, failCount + i,
					simulationParameters.molecules, (i == failCountRange) ? allAssignments : null);
			tp += r.getTP();
			fp += r.getFP();
			fn += r.getFN();
			p += r.getPositives();
			n += r.getNegatives();
		}
		// Normalise by the number of evaluations
		final int norm = failCountRange + 1;
		p = (int) Math.round((double) p / norm);
		n = (int) Math.round((double) n / norm);
		return new FractionClassificationResult(tp / norm, fp / norm, 0, fn / norm, p, n);
	}

	private MultiPathFilter createMPF(DirectFilter filter)
	{
		return new MultiPathFilter(filter, residualsThreshold);
	}

	/**
	 * Score the filter using the results list and the configured fail count.
	 *
	 * @param filter
	 *            the filter
	 * @param resultsList
	 *            the results list
	 * @param allAssignments
	 *            all the assignments
	 * @return The score
	 */
	private ArrayList<FractionalAssignment[]> getAssignments(DirectFilter filter)
	{
		final MultiPathFilter multiPathFilter = createMPF(filter);

		ArrayList<FractionalAssignment[]> allAssignments = new ArrayList<FractionalAssignment[]>(resultsList.length);
		multiPathFilter.fractionScore(resultsList, failCount + failCountRange, simulationParameters.molecules,
				allAssignments);
		return allAssignments;
	}

	public StringBuilder createResult(DirectFilter filter, FractionClassificationResult r)
	{
		StringBuilder sb = new StringBuilder(resultsPrefix);
		sb.append(filter.getName()).append(resultsPrefix2).append(resultsPrefix3);

		int i = 0;

		// TODO - Fix the scores that we show since we no longer have TN results
		// We could set:
		// TN as any candidate that does not match a true result.
		// FN as any candidate that does match a true result (that is not matched by any fit result)
		// To do this properly would require that we store all the matches of candidates to the data.
		// These can then be totalled up given the candidates that have not been used to create a positive. 

		// Integer results
		final ClassificationResult r2 = (requireIntegerResults) ? createIntegerResult(r) : null;

		add(sb, r2.getTP(), i++);
		add(sb, r2.getFP(), i++);
		add(sb, r2.getFN(), i++);
		add(sb, r2.getPrecision(), i++);
		add(sb, r2.getRecall(), i++);
		add(sb, r2.getF1Score(), i++);
		add(sb, r2.getJaccard(), i++);

		addCount(sb, r.getTP(), i++);
		addCount(sb, r.getFP(), i++);
		addCount(sb, r.getFN(), i++);
		add(sb, r.getPrecision(), i++);
		add(sb, r.getRecall(), i++);
		add(sb, r.getF1Score(), i++);
		add(sb, r.getJaccard(), i++);

		return sb;
	}

	private ClassificationResult createIntegerResult(FractionClassificationResult r)
	{
		return new ClassificationResult(r.getPositives(), r.getNegatives(), 0,
				simulationParameters.molecules - r.getPositives());
	}

	private FractionClassificationResult getOriginalScore(FractionClassificationResult r)
	{
		throw new RuntimeException("fix this");

		//		// Score the fitting results against the original simulated data:
		//		// TP are all fit results that can be matched to a spot
		//		// FP are all fit results that cannot be matched to a spot
		//		// FN are the number of missed spots
		//		// Note: We cannot calculate TN since this is the number of fit candidates that are 
		//		// filtered after fitting that do not match a spot or were not fitted. 
		//		final double fp = r.getPositives() - r.getTP();
		//		final double fn = simulationParameters.molecules - r.getTP();
		//		return new FractionClassificationResult(r.getTP(), fp, 0, fn);
	}

	private static void add(StringBuilder sb, int value)
	{
		sb.append('\t').append(value);
	}

	private static void add(StringBuilder sb, String value)
	{
		sb.append('\t').append(value);
	}

	private static void add(StringBuilder sb, int value, int i)
	{
		if (showColumns[i])
			add(sb, value);
	}

	private static void addCount(StringBuilder sb, double value, int i)
	{
		if (showColumns[i])
		{
			// Check if the double holds an integer count
			if ((int) value == value)
			{
				sb.append('\t').append((int) value);
			}
			else
			{
				// Otherwise add the counts using at least 2 dp
				if (value > 100)
					sb.append('\t').append(IJ.d2s(value));
				else
					add(sb, Utils.rounded(value));
			}
		}
	}

	private static void add(StringBuilder sb, double value, int i)
	{
		if (showColumns[i])
			add(sb, Utils.rounded(value));
	}

	private void saveFilter(DirectFilter filter)
	{
		// Save the filter to file
		String filename = getFilename("Best_Filter_File", filterFilename);
		if (filename != null)
		{
			filterFilename = filename;

			List<Filter> filters = new ArrayList<Filter>(1);
			filters.add(filter);
			FilterSet filterSet = new FilterSet(filter.getName(), filters);
			List<FilterSet> list = new ArrayList<FilterSet>(1);
			list.add(filterSet);
			saveFilterSet(filterSet, filename);
		}
	}

	static String getFilename(String title, String filename)
	{
		filename = Utils.getFilename(title, filename);
		// Use XML extension
		if (filename != null)
			filename = Utils.replaceExtension(filename, ".xml");
		return filename;
	}

	private static void saveFilterSet(FilterSet filterSet, String filename)
	{
		OutputStreamWriter out = null;
		try
		{
			List<FilterSet> list = new ArrayList<FilterSet>(1);
			list.add(filterSet);
			FileOutputStream fos = new FileOutputStream(filename);
			out = new OutputStreamWriter(fos, "UTF-8");
			// Use the instance so we can catch the exception
			out.write(XmlUtils.prettyPrintXml(XStreamWrapper.getInstance().toXML(list)));
		}
		catch (Exception e)
		{
			IJ.log("Unable to save the filter sets to file: " + e.getMessage());
		}
		finally
		{
			if (out != null)
			{
				try
				{
					out.close();
				}
				catch (IOException e)
				{
					// Ignore
				}
			}
		}
	}

	/**
	 * Save the filter set to a file prompted from the user
	 * 
	 * @param filterSet
	 * @param setNumber
	 */
	private void saveFilterSet(FilterSet filterSet, int setNumber)
	{
		stopTimer();

		String filename = getFilename("Filter_set_" + setNumber, filterSetFilename);
		if (filename != null)
		{
			filterSetFilename = filename;
			saveFilterSet(filterSet, filename);
		}

		startTimer();
	}

	/**
	 * Save PeakFit configuration template using the current benchmark settings.
	 * 
	 * @param topFilterSummary
	 */
	private void saveTemplate(String topFilterSummary)
	{
		FitEngineConfiguration config = new FitEngineConfiguration(new FitConfiguration());
		if (!updateAllConfiguration(config, true))
		{
			IJ.log("Unable to create the template configuration");
			return;
		}

		// Remove the PSF width to make the template generic
		config.getFitConfiguration().setInitialPeakStdDev(0);

		String filename = getFilename("Template_File", templateFilename);
		if (filename != null)
		{
			templateFilename = filename;
			GlobalSettings settings = new GlobalSettings();
			settings.setNotes(getNotes(topFilterSummary));
			settings.setFitEngineConfiguration(config);
			if (!SettingsManager.saveSettings(settings, filename))
				IJ.log("Unable to save the template configuration");
		}
	}

	private String getNotes(String topFilterSummary)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Benchmark template\n");
		if (!Utils.isNullOrEmpty(resultsTitle))
			addField(sb, "Filter Analysis Title", resultsTitle);
		// Add create data settings.
		// Just add the columns and the data from the summary window
		final String header = createResultsHeader(true);
		addField(sb, "Filter Analysis Summary Fields", header);
		addField(sb, "Filter Analysis Summary Values", topFilterSummary);
		// Now pick out key values...
		addKeyFields(sb, header, topFilterSummary, new String[] { "Molecules", "Density", "SNR", "s (nm)", "a (nm)",
				"Lower D", "Upper D", "Lower factor", "Upper factor" });

		// Add any other settings that may be useful in the template
		addField(sb, "Created", getCurrentTimeStamp());
		return sb.toString();
	}

	static void addField(StringBuilder sb, String field, String value)
	{
		sb.append(field).append(": ").append(value).append('\n');
	}

	static void addKeyFields(StringBuilder sb, String header, String summary, String[] fields)
	{
		String[] labels = header.split("\t");
		String[] values = summary.split("\t");
		for (String field : fields)
		{
			for (int i = 0; i < labels.length; i++)
			{
				if (labels[i].startsWith(field))
				{
					addField(sb, labels[i], values[i]);
					break;
				}
			}
		}
	}

	static String getCurrentTimeStamp()
	{
		SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date now = new Date();
		String strDate = sdfDate.format(now);
		return strDate;
	}

	/**
	 * Depth analysis.
	 *
	 * @param allAssignments
	 *            The assignments generated from running the filter (or null)
	 * @param filter
	 *            the filter
	 * @return the assignments
	 */
	private ArrayList<FractionalAssignment[]> depthAnalysis(ArrayList<FractionalAssignment[]> allAssignments,
			DirectFilter filter)
	{
		// TODO : This analysis ignores the partial match distance.
		// Use the score for each result to get a weighted histogram. 

		if (!depthRecallAnalysis || simulationParameters.fixedDepth)
			return null;

		// Build a histogram of the number of spots at different depths
		final double[] depths = depthStats.getValues();
		final double range = simulationParameters.depth / simulationParameters.a / 2;
		double[] limits = { -range, range };

		//final int bins = Math.max(10, simulationParameters.molecules / 100);
		//final int bins = Utils.getBinsSturges(depths.length);
		final int bins = Utils.getBinsSqrt(depths.length);
		double[][] h1 = Utils.calcHistogram(depths, limits[0], limits[1], bins);
		double[][] h2 = Utils.calcHistogram(depthFitStats.getValues(), limits[0], limits[1], bins);

		// To get the number of TP at each depth will require that the filter is run 
		// manually to get the results that pass.
		if (allAssignments == null)
			allAssignments = getAssignments(filter);

		double[] depths2 = new double[results.size()];
		int count = 0;
		for (FractionalAssignment[] assignments : allAssignments)
		{
			if (assignments == null)
				continue;
			for (int i = 0; i < assignments.length; i++)
			{
				final CustomFractionalAssignment c = (CustomFractionalAssignment) assignments[i];
				depths2[count++] = c.peak.error;
			}
		}
		depths2 = Arrays.copyOf(depths2, count);

		// Build a histogram using the same limits
		double[][] h3 = Utils.calcHistogram(depths2, limits[0], limits[1], bins);

		// Convert pixel depth to nm
		for (int i = 0; i < h1[0].length; i++)
			h1[0][i] *= simulationParameters.a;
		limits[0] *= simulationParameters.a;
		limits[1] *= simulationParameters.a;

		// Produce a histogram of the number of spots at each depth
		String title1 = TITLE + " Depth Histogram";
		Plot2 plot1 = new Plot2(title1, "Depth (nm)", "Frequency");
		plot1.setLimits(limits[0], limits[1], 0, Maths.max(h1[1]));
		plot1.setColor(Color.black);
		plot1.addPoints(h1[0], h1[1], Plot2.BAR);
		plot1.addLabel(0, 0, "Black = Spots; Blue = Fitted; Red = Filtered");
		plot1.setColor(Color.blue);
		plot1.addPoints(h1[0], h2[1], Plot2.BAR);
		plot1.setColor(Color.red);
		plot1.addPoints(h1[0], h3[1], Plot2.BAR);
		plot1.setColor(Color.magenta);
		PlotWindow pw1 = Utils.display(title1, plot1);
		if (Utils.isNewWindow())
			wo.add(pw1);

		// Interpolate
		final double halfBinWidth = (h1[0][1] - h1[0][0]) * 0.5;
		// Remove final value of the histogram as this is at the upper limit of the range (i.e. count zero)
		h1[0] = Arrays.copyOf(h1[0], h1[0].length - 1);
		h1[1] = Arrays.copyOf(h1[1], h1[0].length);
		h2[1] = Arrays.copyOf(h2[1], h1[0].length);
		h3[1] = Arrays.copyOf(h3[1], h1[0].length);

		// TODO : Fix the smoothing since LOESS sometimes does not work.
		// Perhaps allow configuration of the number of histogram bins and the smoothing bandwidth.

		// Use minimum of 3 points for smoothing
		// Ensure we use at least x% of data
		double bandwidth = Math.max(3.0 / h1[0].length, 0.15);
		LoessInterpolator loess = new LoessInterpolator(bandwidth, 1);
		PolynomialSplineFunction spline1 = loess.interpolate(h1[0], h1[1]);
		PolynomialSplineFunction spline2 = loess.interpolate(h1[0], h2[1]);
		PolynomialSplineFunction spline3 = loess.interpolate(h1[0], h3[1]);
		// Use a second interpolator in case the LOESS fails
		LinearInterpolator lin = new LinearInterpolator();
		PolynomialSplineFunction spline1b = lin.interpolate(h1[0], h1[1]);
		PolynomialSplineFunction spline2b = lin.interpolate(h1[0], h2[1]);
		PolynomialSplineFunction spline3b = lin.interpolate(h1[0], h3[1]);

		// Increase the number of points to show a smooth curve
		double[] points = new double[bins * 5];
		limits = Maths.limits(h1[0]);
		final double interval = (limits[1] - limits[0]) / (points.length - 1);
		double[] v = new double[points.length];
		double[] v2 = new double[points.length];
		double[] v3 = new double[points.length];
		for (int i = 0; i < points.length - 1; i++)
		{
			points[i] = limits[0] + i * interval;
			v[i] = getSplineValue(spline1, spline1b, points[i]);
			v2[i] = getSplineValue(spline2, spline2b, points[i]);
			v3[i] = getSplineValue(spline3, spline3b, points[i]);
			points[i] += halfBinWidth;
		}
		// Final point on the limit of the spline range
		int ii = points.length - 1;
		v[ii] = getSplineValue(spline1, spline1b, limits[1]);
		v2[ii] = getSplineValue(spline2, spline2b, limits[1]);
		v3[ii] = getSplineValue(spline3, spline3b, limits[1]);
		points[ii] = limits[1] + halfBinWidth;

		// Calculate recall
		for (int i = 0; i < v.length; i++)
		{
			v2[i] = v2[i] / v[i];
			v3[i] = v3[i] / v[i];
		}

		final double halfSummaryDepth = summaryDepth * 0.5;

		String title2 = TITLE + " Depth Histogram (normalised)";
		Plot2 plot2 = new Plot2(title2, "Depth (nm)", "Recall");
		plot2.setLimits(limits[0] + halfBinWidth, limits[1] + halfBinWidth, 0, Maths.min(1, Maths.max(v2)));
		plot2.setColor(Color.black);
		plot2.addLabel(0, 0, "Blue = Fitted; Red = Filtered");
		plot2.setColor(Color.blue);
		plot2.addPoints(points, v2, Plot2.LINE);
		plot2.setColor(Color.red);
		plot2.addPoints(points, v3, Plot2.LINE);
		plot2.setColor(Color.magenta);
		if (-halfSummaryDepth - halfBinWidth >= limits[0])
		{
			plot2.drawLine(-halfSummaryDepth, 0, -halfSummaryDepth,
					getSplineValue(spline3, spline3b, -halfSummaryDepth - halfBinWidth) /
							getSplineValue(spline1, spline1b, -halfSummaryDepth - halfBinWidth));
		}
		if (halfSummaryDepth - halfBinWidth <= limits[1])
		{
			plot2.drawLine(halfSummaryDepth, 0, halfSummaryDepth,
					getSplineValue(spline3, spline3b, halfSummaryDepth - halfBinWidth) /
							getSplineValue(spline1, spline1b, halfSummaryDepth - halfBinWidth));
		}
		PlotWindow pw2 = Utils.display(title2, plot2);
		if (Utils.isNewWindow())
			wo.add(pw2);

		return allAssignments;
	}

	private double getSplineValue(PolynomialSplineFunction spline, PolynomialSplineFunction spline2, double x)
	{
		double y = spline.value(x);
		if (Double.isNaN(y))
			y = spline2.value(x);
		return y;
	}

	/**
	 * Score analysis.
	 *
	 * @param allAssignments
	 *            The assignments generated from running the filter (or null)
	 * @param filter
	 *            the filter
	 */
	private void scoreAnalysis(ArrayList<FractionalAssignment[]> allAssignments, DirectFilter filter)
	{
		if (!scoreAnalysis)
			return;

		// Build a histogram of the fitted spots that were available to be scored
		double[] signal = signalFactorStats.getValues();
		double[] distance = distanceStats.getValues();
		double range = BenchmarkSpotFit.signalFactor * upperSignalFactor / 100.0;
		double[] limits1 = { -range, range };
		double[] limits2 = { 0,
				simulationParameters.a * BenchmarkSpotFit.distanceInPixels * upperMatchDistance / 100.0 };

		final int bins = Math.max(10, simulationParameters.molecules / 100);
		double[][] h1 = Utils.calcHistogram(signal, limits1[0], limits1[1], bins);
		double[][] h2 = Utils.calcHistogram(distance, limits2[0], limits2[1], bins);

		// Run the filter manually to get the results that pass.
		if (allAssignments == null)
			allAssignments = getAssignments(filter);

		double[] signal2 = new double[results.size()];
		double[] distance2 = new double[results.size()];
		int count = 0;
		double sumSignal = 0, sumDistance = 0;
		for (FractionalAssignment[] assignments : allAssignments)
		{
			if (assignments == null)
				continue;
			for (int i = 0; i < assignments.length; i++)
			{
				final CustomFractionalAssignment c = (CustomFractionalAssignment) assignments[i];
				sumSignal += signal2[count] = c.sf;
				sumDistance += distance2[count] = c.getDistance();
				count++;
			}
		}
		signal2 = Arrays.copyOf(signal2, count);
		distance2 = Arrays.copyOf(distance2, count);

		// Build a histogram using the same limits
		double[][] h1b = Utils.calcHistogram(signal2, limits1[0], limits1[1], bins);
		double[][] h2b = Utils.calcHistogram(distance2, limits2[0], limits2[1], bins);

		// Draw distance histogram first
		String title2 = TITLE + " Distance Histogram";
		Plot2 plot2 = new Plot2(title2, "Distance (nm)", "Frequency");
		plot2.setLimits(limits2[0], limits2[1], 0, Maths.max(h2[1]));
		plot2.setColor(Color.black);
		plot2.addLabel(0, 0, String.format("Blue = Fitted (%s); Red = Filtered (%s)",
				Utils.rounded(distanceStats.getMean()), Utils.rounded(sumDistance / count)));
		plot2.setColor(Color.blue);
		plot2.addPoints(h2[0], h2[1], Plot2.BAR);
		plot2.setColor(Color.red);
		plot2.addPoints(h2b[0], h2b[1], Plot2.BAR);
		PlotWindow pw2 = Utils.display(title2, plot2);
		if (Utils.isNewWindow())
			wo.add(pw2);

		// Draw signal factor histogram
		String title1 = TITLE + " Signal Factor Histogram";
		Plot2 plot1 = new Plot2(title1, "Signal Factor", "Frequency");
		plot1.setLimits(limits1[0], limits1[1], 0, Maths.max(h1[1]));
		plot1.setColor(Color.black);
		plot1.addLabel(0, 0, String.format("Blue = Fitted (%s); Red = Filtered (%s)",
				Utils.rounded(signalFactorStats.getMean()), Utils.rounded(sumSignal / count)));
		plot1.setColor(Color.blue);
		plot1.addPoints(h1[0], h1[1], Plot2.BAR);
		plot1.setColor(Color.red);
		plot1.addPoints(h1b[0], h1b[1], Plot2.BAR);
		PlotWindow pw1 = Utils.display(title1, plot1);
		if (Utils.isNewWindow())
			wo.add(pw1);
	}

	public class FilterScore implements Comparable<FilterScore>
	{
		DirectFilter filter;
		double score, criteria;
		boolean atLimit;

		public FilterScore(DirectFilter filter, double score, double criteria, boolean atLimit)
		{
			update(filter, score, criteria, atLimit);
		}

		public void update(DirectFilter filter, double score, double criteria, boolean atLimit)
		{
			this.filter = filter;
			this.score = score;
			this.criteria = criteria;
			this.atLimit = atLimit;
		}

		public int compareTo(FilterScore that)
		{
			if (this.score > that.score)
				return -1;
			if (this.score < that.score)
				return 1;
			if (this.criteria > that.criteria)
				return -1;
			if (this.criteria < that.criteria)
				return 1;
			return 0;
		}
	}

	public class NamedPlot implements Comparable<NamedPlot>
	{
		String name, xAxisName;
		double[] xValues, yValues;
		double score;

		public NamedPlot(String name, String xAxisName, double[] xValues, double[] yValues)
		{
			this.name = name;
			updateValues(xAxisName, xValues, yValues);
		}

		public void updateValues(String xAxisName, double[] xValues, double[] yValues)
		{
			this.xAxisName = xAxisName;
			this.xValues = xValues;
			this.yValues = yValues;
			this.score = getMaximum(yValues);
		}

		public int compareTo(NamedPlot o)
		{
			if (score > o.score)
				return -1;
			if (score < o.score)
				return 1;
			return 0;
		}
	}

	/**
	 * Allow the genetic algorithm to be stopped using the escape key
	 */
	private class InterruptChecker extends ToleranceChecker
	{
		final int convergedCount;
		int count = 0;

		public InterruptChecker(double relative, double absolute, int convergedCount)
		{
			super(relative, absolute);
			this.convergedCount = convergedCount;
		}

		@Override
		public boolean converged(Chromosome previous, Chromosome current)
		{
			if (super.converged(previous, current))
				count++;
			else
				count = 0;
			// Allow no convergence except when escape is pressed
			if (convergedCount >= 0 && count > convergedCount)
				return true;
			if (IJ.escapePressed())
			{
				Utils.log("STOPPED " + ga_statusPrefix);
				IJ.resetEscape(); // Allow the plugin to continue processing
				return true;
			}
			return false;
		}
	}

	// Used to implement the FitnessFunction interface 
	private String ga_statusPrefix;
	private Population ga_population;

	// Used for the scoring of filter sets
	private MultiPathFitResults[] ga_resultsList = null;
	private MultiPathFitResults[] ga_resultsListToScore = null;
	private boolean ga_subset;
	private int ga_iteration;
	private ScoreResult[] ga_scoreResults = null;
	private int ga_scoreIndex = 0;

	private class ScoreResult
	{
		final double score, criteria;
		//final FractionClassificationResult r;
		final DirectFilter filter;
		final String text;

		public ScoreResult(double score, double criteria,
				//FractionClassificationResult r, 
				DirectFilter filter, String text)
		{
			this.score = score;
			this.criteria = criteria;
			//this.r = r;
			this.filter = filter;
			this.text = text;
		}
	}

	private class ScoreJob
	{
		final DirectFilter filter;
		final int index;

		ScoreJob(DirectFilter filter, int index)
		{
			this.filter = filter;
			this.index = index;
		}
	}

	/**
	 * Used to allow multi-threading of the scoring the filters
	 */
	private class ScoreWorker implements Runnable
	{
		volatile boolean finished = false;
		final BlockingQueue<ScoreJob> jobs;
		final ScoreResult[] scoreResults;
		final boolean createTextResult;

		public ScoreWorker(BlockingQueue<ScoreJob> jobs, ScoreResult[] scoreResults, boolean createTextResult)
		{
			this.jobs = jobs;
			this.scoreResults = scoreResults;
			this.createTextResult = createTextResult;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Runnable#run()
		 */
		public void run()
		{
			try
			{
				while (!finished)
				{
					ScoreJob job = jobs.take();
					if (job == null || job.index == -1 || finished)
						break;
					run(job);
				}
			}
			catch (InterruptedException e)
			{
				System.out.println(e.toString());
				throw new RuntimeException(e);
			}
			finally
			{
				finished = true;
			}
		}

		private void run(ScoreJob job)
		{
			if (Utils.isInterrupted())
			{
				finished = true;
				return;
			}
			showProgress();
			// Directly write to the result array, this is thread safe
			scoreResults[job.index] = scoreFilter(job.filter, createTextResult);
		}
	}

	/** The total progress. */
	int progress, stepProgress, totalProgress;

	/**
	 * Show progress.
	 */
	private synchronized void showProgress()
	{
		if (++progress % stepProgress == 0)
		{
			if (Utils.showStatus("Frame: " + progress + " / " + totalProgress))
				IJ.showProgress(progress, totalProgress);
		}
	}

	private ScoreResult[] scoreFilters(FilterSet filterSet, boolean createTextResult)
	{
		if (filterSet.size() == 0)
			return null;

		initialiseScoring(filterSet);

		ScoreResult[] scoreResults = new ScoreResult[filterSet.size()];

		if (scoreResults.length == 1)
		{
			// No need to multi-thread this			
			scoreResults[0] = scoreFilter((DirectFilter) filterSet.getFilters().get(0), createTextResult);
		}
		else
		{
			// Multi-thread score all the result
			final int nThreads = getThreads(scoreResults.length);
			final BlockingQueue<ScoreJob> jobs = new ArrayBlockingQueue<ScoreJob>(nThreads * 2);
			final List<ScoreWorker> workers = new LinkedList<ScoreWorker>();
			final List<Thread> threads = new LinkedList<Thread>();
			for (int i = 0; i < nThreads; i++)
			{
				final ScoreWorker worker = new ScoreWorker(jobs, scoreResults, createTextResult);
				final Thread t = new Thread(worker);
				workers.add(worker);
				threads.add(t);
				t.start();
			}

			int index = 0;
			totalProgress = scoreResults.length;
			stepProgress = Utils.getProgressInterval(totalProgress);
			progress = 0;
			for (Filter filter : filterSet.getFilters())
			{
				put(jobs, new ScoreJob((DirectFilter) filter, index++));
			}
			// Finish all the worker threads by passing in a null job
			for (int i = 0; i < threads.size(); i++)
			{
				put(jobs, new ScoreJob(null, -1));
			}

			// Wait for all to finish
			for (int i = 0; i < threads.size(); i++)
			{
				try
				{
					threads.get(i).join();
				}
				catch (InterruptedException e)
				{
					e.printStackTrace();
				}
			}
			threads.clear();
			IJ.showProgress(1);

			// In case the threads were interrupted
			if (Utils.isInterrupted())
				scoreResults = null;
		}

		finishScoring();

		return scoreResults;
	}

	private static int getThreads(int length)
	{
		return Math.max(1, Math.min(Prefs.getThreads(), length));
	}

	private void put(BlockingQueue<ScoreJob> jobs, ScoreJob job)
	{
		try
		{
			jobs.put(job);
		}
		catch (InterruptedException e)
		{
			throw new RuntimeException("Unexpected interruption", e);
		}
	}

	/**
	 * Initialise the results list used for scoring the filters. This is shared with the genetic algorithm.
	 *
	 * @param filterSet
	 *            the filter set
	 */
	private void initialiseScoring(FilterSet filterSet)
	{
		// Initialise with the candidate true and false negative scores
		ga_resultsListToScore = ga_resultsList;
		ga_subset = false;

		if (filterSet.size() < 2)
			return;

		Filter weakest = filterSet.createWeakestFilter();
		if (weakest != null)
		{
			ga_subset = true;
			ga_resultsListToScore = createMPF((DirectFilter) weakest).filterSubset(ga_resultsList,
					failCount + failCountRange, true);
		}
	}

	private ScoreResult scoreFilter(DirectFilter filter, boolean createTextResult)
	{
		final FractionClassificationResult r = scoreFilter(filter, ga_resultsListToScore);

		// DEBUG - Test if the two methods produce the same results
		FractionClassificationResult r2 = scoreFilter(filter, BenchmarkFilterAnalysis.clonedResultsList);
		if (!gdsc.core.utils.DoubleEquality.almostEqualRelativeOrAbsolute(r.getTP(), r2.getTP(), 1e-6, 1e-10) ||
				!gdsc.core.utils.DoubleEquality.almostEqualRelativeOrAbsolute(r.getFP(), r2.getFP(), 1e-6, 1e-10) ||
				!gdsc.core.utils.DoubleEquality.almostEqualRelativeOrAbsolute(r.getFN(), r2.getFN(), 1e-6, 1e-10))
		{
			System.out.printf("TP %f != %f, FP %f != %f, FN %f != %f\n", r.getTP(), r2.getTP(), r.getFP(), r2.getFP(),
					r.getFN(), r2.getFN());
		}
		else
			System.out.println("Matched scores");

		final double score = getScore(r);
		final double criteria = getCriteria(r);

		// Show the result if it achieves the criteria limit 
		final String text = (createTextResult && criteria >= minCriteria) ? createResult(filter, r).toString() : null;

		return new ScoreResult(score, criteria, filter, text);
	}

	/**
	 * Finish scoring and reset the subset
	 *
	 * @param filterSet
	 *            the filter set
	 */
	private void finishScoring()
	{
		if (ga_subset)
		{
			resetFailCount(ga_resultsListToScore);
		}
	}

	private void resetFailCount(MultiPathFitResults[] list)
	{
		for (int i = 0; i < list.length; i++)
		{
			for (int j = 0; j < list[i].multiPathFitResults.length; j++)
			{
				list[i].multiPathFitResults[j].resetFailCount();
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.smlm.ga.FitnessFunction#initialise(java.util.List)
	 */
	public void initialise(List<? extends Chromosome> individuals)
	{
		ga_iteration++;
		ga_scoreIndex = 0;
		ga_scoreResults = scoreFilters(new FilterSet(populationToFilters(individuals)), false);
	}

	private ArrayList<Filter> populationToFilters(List<? extends Chromosome> individuals)
	{
		ArrayList<Filter> filters = new ArrayList<Filter>(individuals.size());
		for (Chromosome c : individuals)
			filters.add((DirectFilter) c);
		return filters;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.smlm.ga.FitnessFunction#fitness(gdsc.smlm.ga.Chromosome)
	 */
	public double fitness(Chromosome chromosome)
	{
		// In case the user aborted with Escape
		if (ga_scoreResults == null)
			return 0;

		// Assume that fitness will be called in the order of the individuals passed to the initialise function.
		final ScoreResult scoreResult = ga_scoreResults[ga_scoreIndex++];

		double score = scoreResult.score;
		final double criteria = scoreResult.criteria;

		if (strictFitness)
		{
			// No fitness for those below the criteria 
			if (criteria < minCriteria)
				// To flag that it has been scored, but is invalid.
				score = -1;
		}
		else
		{
			// Make sure all individuals who pass the criteria are above those that do not.
			// This will work unless we are scoring using the counts (i.e. scores that may exceed 1) 
			if (criteria >= minCriteria)
				score += 1;
		}

		return score;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.smlm.ga.FitnessFunction#shutdown()
	 */
	public void shutdown()
	{
		// Report the score for the best filter
		List<? extends Chromosome> individuals = ga_population.getIndividuals();
		ChromosomeComparator.sort(individuals);

		DirectFilter filter = (DirectFilter) individuals.get(0);

		// This filter may not have been part of the scored subset so use the entire results set for reporting
		FractionClassificationResult r = scoreFilter(filter, ga_resultsList);

		final StringBuilder text = createResult(filter, r);
		add(text, ga_iteration);
		gaWindow.append(text.toString());
	}

	private double limit = 0;

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.core.logging.TrackProgress#progress(double)
	 */
	public void progress(double fraction)
	{
		if (fraction == 1)
		{
			// Reset
			limit = 0;
			IJ.showProgress(fraction);
			return;
		}

		// Show only 2% changes
		if (fraction < limit)
			return;

		limit = fraction + 0.02;
		IJ.showProgress(fraction);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.core.logging.TrackProgress#progress(long, long)
	 */
	public void progress(long position, long total)
	{
		progress((double) position / total);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.core.logging.TrackProgress#log(java.lang.String, java.lang.Object[])
	 */
	public void log(String format, Object... args)
	{
		// Ignore		
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.core.logging.TrackProgress#status(java.lang.String, java.lang.Object[])
	 */
	public void status(String format, Object... args)
	{
		IJ.showStatus(ga_statusPrefix + String.format(format, args));
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see gdsc.core.logging.TrackProgress#isEnded()
	 */
	public boolean isEnded()
	{
		// Ignore		
		return false;
	}

	/**
	 * Updates the given configuration using the latest settings used in benchmarking spot filters, fitting and
	 * filtering.
	 *
	 * @param config
	 *            the configuration
	 * @param useLatest
	 *            Use the latest best filter. Otherwise use the highest scoring.
	 * @return true, if successful
	 */
	public static boolean updateAllConfiguration(FitEngineConfiguration config, boolean useLatest)
	{
		// Do this first as it sets the initial SD
		if (!BenchmarkSpotFit.updateConfiguration(config))
			return false;
		if (!BenchmarkSpotFilter.updateConfiguration(config))
			return false;
		if (!updateConfiguration(config, useLatest))
			return false;
		return true;
	}

	/**
	 * Updates the given configuration using the latest settings used in benchmarking filtering.
	 *
	 * @param config
	 *            the configuration
	 * @param useLatest
	 *            Use the latest best filter. Otherwise use the highest scoring.
	 * @return true, if successful
	 */
	public static boolean updateConfiguration(FitEngineConfiguration config, boolean useLatest)
	{
		if (scores.isEmpty())
			return false;

		FilterResult best;
		if (useLatest)
		{
			best = scores.get(scores.size() - 1);
		}
		else
		{
			best = getBestResult();
		}

		if (!(best.filter instanceof IMultiFilter))
			return false;

		IMultiFilter filter = (IMultiFilter) (best.filter);

		final FitConfiguration fitConfig = config.getFitConfiguration();

		fitConfig.setCoordinateShiftFactor(filter.getShift());
		fitConfig.setSignalStrength(filter.getSNR());
		fitConfig.setMinPhotons(filter.getSignal());
		fitConfig.setMinWidthFactor(filter.getMinWidth());
		fitConfig.setWidthFactor(filter.getMaxWidth());
		fitConfig.setPrecisionThreshold(filter.getPrecision());
		fitConfig.setPrecisionUsingBackground(filter.isPrecisionUsesLocalBackground());

		// We could set the fail count range dynamically using a window around the best filter 

		config.setFailuresLimit((best.failCount + best.failCountRange / 2));

		return true;
	}

	private static FilterResult getBestResult()
	{
		if (!scores.isEmpty())
		{
			// Clone so we can sort the list by fail count
			@SuppressWarnings("unchecked")
			ArrayList<FilterResult> scores2 = (ArrayList<FilterResult>) scores.clone();
			Collections.sort(scores2, new Comparator<FilterResult>()
			{
				public int compare(FilterResult o1, FilterResult o2)
				{
					int result = o1.failCount - o2.failCount;
					if (result != 0)
						return result;
					return o1.failCountRange - o2.failCountRange;
				}
			});

			int maxi = 0;
			double max = 0;
			for (int i = 0; i < scores2.size(); i++)
			{
				double score = scores2.get(i).score;
				if (max >= score)
					continue;

				// Round this so that small differences are ignored.
				// This should favour filters with lower fail count.
				double diff = Maths.round(score - max, 3);
				if (diff <= 0)
					continue;

				max = score;
				maxi = i;
			}
			return scores2.get(maxi);
		}
		return null;
	}
}
