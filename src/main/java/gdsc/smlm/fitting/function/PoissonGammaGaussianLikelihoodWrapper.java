package gdsc.smlm.fitting.function;

/*----------------------------------------------------------------------------- 
 * GDSC SMLM Software
 * 
 * Copyright (C) 2013 Alex Herbert
 * Genome Damage and Stability Centre
 * University of Sussex, UK
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *---------------------------------------------------------------------------*/

import gdsc.smlm.utils.Bessel;

import java.util.Arrays;

import org.apache.commons.math3.special.Erf;
import org.apache.commons.math3.util.FastMath;

/**
 * This is a wrapper for any function to compute the negative log-likelihood assuming a Poisson-Gamma-Gaussian
 * distribution.
 * <p>
 * For each observed value the log-likelihood is computed from the Poisson-Gamma-Gaussian distribution (a Poisson
 * convolved with a Gamma distribution convolved with a Gaussian). The Poisson-Gamma distribution is derived
 * analytically in the paper Maximilian H Ulbrich & Ehud Y Isacoff, Nature Methods - 4, 319 - 321 (2007) to explain the
 * probability distribution of ADUs given a fixed photon level per pixel and set gain in an EM-CCD camera (The Poisson
 * distribution models the photon count and the Gamma distribution models the EM-gain). This is then numerically
 * convolved with a Gaussian distribution to model the read noise of the camera.
 * <p>
 * The distribution of Ulbrich & Isacoff has no analytical solution to the convolution with a Gaussian. However the
 * convolution with a Gaussian has the most effect when the counts are low. The Poisson-Gamma-Gaussian can be
 * approximated using the Poisson-Gamma and a partial convolution with a Gaussian at low counts. This method is provided
 * as Python source code within the supplementary information of the paper Mortensen, et al (2010) Nature Methods 7,
 * 377-383. This Java implementation is based on the Python code.
 * <P>
 * The mean of the Poisson distribution is set using the expected value generated by the provided function. The EM-gain
 * for the Gamma distribution and standard deviation of the Gaussian is fixed and set in the constructor. The mean of
 * the Gaussian is assumed to be zero.
 * <p>
 * The negative log-likelihood can be evaluated over the entire set of observed values or for a chosen observed value.
 */
public class PoissonGammaGaussianLikelihoodWrapper
{
	final private NonLinearFunction f;
	final private double[] a, data;
	final private int n;
	/**
	 * The inverse scale of the Gamma distribution (e.g. the inverse of the EM-gain multiplication factor)
	 */
	final private double alpha;
	/**
	 * The standard deviation of the Gaussian (e.g. Width of the noise distribution in the EMCCD output)
	 */
	final private double sigma;

	private final double twoSigma2;
	private final double sqrt2sigma2;
	private final double sqrt2piSigma2;

	private double lastScore;
	private double[] lastVariables;

	/**
	 * Initialise the function.
	 * <p>
	 * The input parameters must be the full parameters for the non-linear function. Only those parameters with gradient
	 * indices should be passed in to the functions to obtain the value (and gradient).
	 * 
	 * @param f
	 *            The function to be used to calculated the expected values
	 * @param a
	 *            The initial parameters for the function
	 * @param k
	 *            The observed values
	 * @param n
	 *            The number of observed values
	 * @param alpha
	 *            Inverse gain of the EMCCD chip
	 * @param s
	 *            The Gaussian standard deviation
	 */
	public PoissonGammaGaussianLikelihoodWrapper(NonLinearFunction f, double[] a, double[] k, int n, double alpha,
			double s)
	{
		this.f = f;
		this.a = Arrays.copyOf(a, a.length);
		this.data = k;
		this.n = n;
		this.alpha = alpha;
		this.sigma = s;
		twoSigma2 = 2 * s * s;
		sqrt2sigma2 = Math.sqrt(2 * s * s);
		sqrt2piSigma2 = Math.sqrt(2 * Math.PI * s * s);
	}

	/**
	 * Copy the variables into the appropriate parameter positions for the NonLinearFunction
	 * 
	 * @param variables
	 */
	private void initialiseFunction(double[] variables)
	{
		int[] gradientIndices = f.gradientIndices();
		for (int i = 0; i < gradientIndices.length; i++)
			a[gradientIndices[i]] = variables[i];
		f.initialise(a);
	}

	/**
	 * Compute the value
	 * 
	 * @param variables
	 *            The variables of the function
	 * @return The negative log likelihood
	 */
	public double value(double[] variables)
	{
		// Check if we have a cached score
		if (sameVariables(variables))
			return lastScore;

		lastVariables = null;
		initialiseFunction(variables);

		// Compute the negative log-likelihood
		double ll = 0;
		for (int i = 0; i < n; i++)
		{
			final double eta = f.eval(i);
			ll -= pseudoLikelihood(data[i], eta);
		}
		return ll;
	}

	private static final double twoSqrtPi = 2 * Math.sqrt(Math.PI);
	private static final double sqrt2pi = Math.sqrt(2 * Math.PI);

	/**
	 * This code is adapted from the Python source code within the supplementary information of the paper Mortensen, et
	 * al (2010) Nature Methods 7, 377-383.
	 * 
	 * @param cij
	 *            The observed count
	 * @param eta
	 *            The expected count
	 * @return The negative log-likelihood
	 */
	private double pseudoLikelihood(final double cij, final double eta)
	{
		// [Poisson PMF] multiplied by the [value at zero]:
		// [(eta^0 / 0!) * FastMath.exp(-eta)] * [eta * alpha]
		// FastMath.exp(-eta) * [eta * alpha]
		final double f0 = alpha * FastMath.exp(-eta) * eta;

		// ?
		final double fp0 = f0 * 0.5 * alpha * (eta - 2);

		// The cumulative normal distribution of the read noise
		// at the observed count
		final double conv0 = 0.5 * (1 + Erf.erf(cij / (sqrt2sigma2)));

		// [Noise * Gaussian PMF at observed count] + 
		//  [observed count * cumulative distribution of read noise at observed count]
		// [sigma*FastMath.exp(-cij**2/(twoSigma2))/Math.sqrt(2*pi)] + [cij*conv0]
		final double conv1 = sigma * FastMath.exp(-(cij * cij) / twoSigma2) / sqrt2pi + cij * conv0;

		// ? 
		double temp = (f0 * conv0 + fp0 * conv1 + FastMath.exp(-eta) * gauss(cij));

		if (cij > 0.0)
		{
			// The observed count converted to photons
			final double nij = alpha * cij;

			if (eta * nij > 10000)
			{
				// Approximate Bessel function i1(x) when using large x:
				// i1(x) ~ exp(x)/sqrt(2*pi*x)
				// However the entire equation is logged (creating transform),
				// evaluated then raised to e to prevent overflow error on 
				// large exp(x)

				final double transform = 0.5 * Math.log(alpha * eta / cij) - nij - eta + 2 * Math.sqrt(eta * nij) -
						Math.log(twoSqrtPi * Math.pow(eta * nij, 0.25));
				temp += (FastMath.exp(transform) - f0 - fp0 * cij);
			}
			else
			{
				// Second part of equation 135 but not sure what the 
				// -f0-fp0*cij term is.
				// This indicates that temp should already be the first
				// part of eq.135: FastMath.exp(-eta)*delta(cij)
				temp += (Math.sqrt(alpha * eta / cij) * FastMath.exp(-nij - eta) * Bessel.I1(2 * Math.sqrt(eta * nij)) -
						f0 - fp0 * cij);
			}
		}

		return Math.log(temp);
	}

	private double gauss(final double x)
	{
		return FastMath.exp(-(x * x) / twoSigma2) / sqrt2piSigma2;
	}

	/**
	 * Check if the variable match those last used for computation of the value
	 * 
	 * @param variables
	 * @return True if the variables are the same
	 */
	private boolean sameVariables(double[] variables)
	{
		if (lastVariables != null)
		{
			for (int i = 0; i < variables.length; i++)
				if (variables[i] != lastVariables[i])
					return false;
			return true;
		}
		return false;
	}

	/**
	 * Compute the value of the function at observed value i
	 * 
	 * @param variables
	 *            The variables of the function
	 * @param i
	 *            Observed value i
	 * @return The negative log likelihood
	 */
	public double value(double[] variables, int i)
	{
		initialiseFunction(variables);

		final double mu = f.eval(i);
		return -pseudoLikelihood(data[i], mu);
	}
}