package gdsc.smlm.fitting.function;

/*----------------------------------------------------------------------------- 
 * GDSC SMLM Software
 * 
 * Copyright (C) 2013 Alex Herbert
 * Genome Damage and Stability Centre
 * University of Sussex, UK
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *---------------------------------------------------------------------------*/

import java.util.Arrays;

/**
 * This is a wrapper for any function to compute the negative log-likelihood assuming a Poisson-Gaussian distribution.
 * <p>
 * For each observed value the log-likelihood is computed from the Poisson-Gaussian distribution (a Poisson convolved with
 * a Gaussian). The mean of the Poisson distribution is set using the expected value generated by the provided function. The
 * standard deviation of the Gaussian is fixed and set in the constructor. The mean of the Gaussian is assumed to be zero.
 * <p>
 * The negative log-likelihood can be evaluated over the entire set of observed values or for a chosen observed value.
 * The sum uses a non-normalised Poisson-Gaussian distribution for speed (see
 * {@link PoissonGaussianFunction#pseudoLikelihood(double)} ).
 */
public class PoissonGaussianLikelihoodWrapper
{
	final private NonLinearFunction f;
	final private double[] a, data;
	final private int n;
	final private double s2;
	final private boolean usePicard = false;

	private double lastScore;
	private double[] lastVariables;

	/**
	 * Initialise the function.
	 * <p>
	 * The input parameters must be the full parameters for the non-linear function. Only those parameters with gradient
	 * indices should be passed in to the functions to obtain the value (and gradient).
	 * 
	 * @param f
	 *            The function to be used to calculated the expected values
	 * @param a
	 *            The initial parameters for the function
	 * @param k
	 *            The observed values
	 * @param n
	 *            The number of observed values
	 * @param s
	 *            The Gaussian standard deviation
	 */
	public PoissonGaussianLikelihoodWrapper(NonLinearFunction f, double[] a, double[] k, int n, double s)
	{
		this.f = f;
		this.a = Arrays.copyOf(a, a.length);
		this.data = k;
		this.n = n;
		this.s2 = s * s;
	}

	/**
	 * Copy the variables into the appropriate parameter positions for the NonLinearFunction
	 * 
	 * @param variables
	 */
	private void initialiseFunction(double[] variables)
	{
		int[] gradientIndices = f.gradientIndices();
		for (int i = 0; i < gradientIndices.length; i++)
			a[gradientIndices[i]] = variables[i];
		f.initialise(a);
	}

	/**
	 * Compute the value.
	 * 
	 * @param variables
	 *            The variables of the function
	 * @return The negative log likelihood
	 */
	public double value(double[] variables)
	{
		// Check if we have a cached score
		if (sameVariables(variables))
			return lastScore;

		lastVariables = variables.clone();
		initialiseFunction(variables);

		// Compute the negative log-likelihood to be minimised
		double ll = 0;
		for (int i = 0; i < n; i++)
		{
			final double mu = f.eval(i);
			ll -= PoissonGaussianFunction.pseudoLikelihood(data[i], mu, s2, usePicard);
		}
		lastScore = ll;
		return ll;
	}

	/**
	 * Check if the variable match those last used for computation of the value
	 * 
	 * @param variables
	 * @return True if the variables are the same
	 */
	private boolean sameVariables(double[] variables)
	{
		if (lastVariables != null)
		{
			for (int i = 0; i < variables.length; i++)
				if (variables[i] != lastVariables[i])
					return false;
			return true;
		}
		return false;
	}

	/**
	 * Compute the value of the function at observed value i.
	 * 
	 * @param variables
	 *            The variables of the function
	 * @param i
	 *            Observed value i
	 * @return The negative log likelihood
	 */
	public double value(double[] variables, int i)
	{
		initialiseFunction(variables);

		final double mu = f.eval(i);
		return -PoissonGaussianFunction.pseudoLikelihood(data[i], mu, s2, usePicard);
	}
}